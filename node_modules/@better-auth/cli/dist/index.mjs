#!/usr/bin/env node
import { Command } from 'commander';
import { parse } from 'dotenv';
import semver from 'semver';
import prettier, { format } from 'prettier';
import * as z from 'zod/v4';
import * as fs from 'fs';
import fs__default, { existsSync, readFileSync } from 'fs';
import * as path from 'path';
import path__default from 'path';
import fs$1 from 'fs/promises';
import chalk from 'chalk';
import { intro, log, outro, confirm, isCancel, cancel, spinner, text, select, multiselect } from '@clack/prompts';
import { exec, execSync } from 'child_process';
import { logger, BetterAuthError, createTelemetry, getTelemetryAuthConfig, capitalizeFirstLetter } from 'better-auth';
import Crypto from 'crypto';
import yoctoSpinner from 'yocto-spinner';
import prompts from 'prompts';
import { getAdapter, getMigrations, getAuthTables } from 'better-auth/db';
import { loadConfig } from 'c12';
import babelPresetTypeScript from '@babel/preset-typescript';
import babelPresetReact from '@babel/preset-react';
import { produceSchema } from '@mrleebo/prisma-ast';
import { createAuthClient } from 'better-auth/client';
import { deviceAuthorizationClient } from 'better-auth/client/plugins';
import open from 'open';
import * as os from 'os';
import os__default from 'os';
import { base64 } from '@better-auth/utils/base64';
import 'dotenv/config';

function getPackageInfo(cwd) {
  const packageJsonPath = cwd ? path__default.join(cwd, "package.json") : path__default.join("package.json");
  return JSON.parse(fs__default.readFileSync(packageJsonPath, "utf-8"));
}

function installDependencies({
  dependencies,
  packageManager,
  cwd
}) {
  let installCommand;
  switch (packageManager) {
    case "npm":
      installCommand = "npm install --force";
      break;
    case "pnpm":
      installCommand = "pnpm install";
      break;
    case "bun":
      installCommand = "bun install";
      break;
    case "yarn":
      installCommand = "yarn install";
      break;
    default:
      throw new Error("Invalid package manager");
  }
  const command = `${installCommand} ${dependencies.join(" ")}`;
  return new Promise((resolve, reject) => {
    exec(command, { cwd }, (error, stdout, stderr) => {
      if (error) {
        reject(new Error(stderr));
        return;
      }
      resolve(true);
    });
  });
}

function checkCommand(command) {
  return new Promise((resolve) => {
    exec(`${command} --version`, (error) => {
      if (error) {
        resolve(false);
      } else {
        resolve(true);
      }
    });
  });
}
async function checkPackageManagers() {
  const hasPnpm = await checkCommand("pnpm");
  const hasBun = await checkCommand("bun");
  return {
    hasPnpm,
    hasBun
  };
}

function formatMilliseconds(ms) {
  if (ms < 0) {
    throw new Error("Milliseconds cannot be negative");
  }
  if (ms < 1e3) {
    return `${ms}ms`;
  }
  const seconds = Math.floor(ms / 1e3);
  const milliseconds = ms % 1e3;
  return `${seconds}s ${milliseconds}ms`;
}

const generateSecret = new Command("secret").action(() => {
  const secret = generateSecretHash();
  logger.info(`
Add the following to your .env file: 
${chalk.gray("# Auth Secret") + chalk.green(`
BETTER_AUTH_SECRET=${secret}`)}`);
});
const generateSecretHash = () => {
  return Crypto.randomBytes(32).toString("hex");
};

async function generateAuthConfig({
  format,
  current_user_config,
  spinner,
  plugins,
  database
}) {
  let _start_of_plugins_common_index = {
    START_OF_PLUGINS: {
      type: "regex",
      regex: /betterAuth\([\w\W]*plugins:[\W]*\[()/m,
      getIndex: ({ matchIndex, match }) => {
        return matchIndex + match[0].length;
      }
    }
  };
  const common_indexes = {
    START_OF_PLUGINS: _start_of_plugins_common_index.START_OF_PLUGINS,
    END_OF_PLUGINS: {
      type: "manual",
      getIndex: ({ content, additionalFields }) => {
        const closingBracketIndex = findClosingBracket(
          content,
          additionalFields.start_of_plugins,
          "[",
          "]"
        );
        return closingBracketIndex;
      }
    },
    START_OF_BETTERAUTH: {
      type: "regex",
      regex: /betterAuth\({()/m,
      getIndex: ({ matchIndex }) => {
        return matchIndex + "betterAuth({".length;
      }
    }
  };
  const config_generation = {
    add_plugin: async (opts) => {
      let start_of_plugins = getGroupInfo(
        opts.config,
        common_indexes.START_OF_PLUGINS,
        {}
      );
      if (!start_of_plugins) {
        throw new Error(
          "Couldn't find start of your plugins array in your auth config file."
        );
      }
      let end_of_plugins = getGroupInfo(
        opts.config,
        common_indexes.END_OF_PLUGINS,
        { start_of_plugins: start_of_plugins.index }
      );
      if (!end_of_plugins) {
        throw new Error(
          "Couldn't find end of your plugins array in your auth config file."
        );
      }
      let new_content;
      if (opts.direction_in_plugins_array === "prepend") {
        new_content = insertContent({
          line: start_of_plugins.line,
          character: start_of_plugins.character,
          content: opts.config,
          insert_content: `${opts.pluginFunctionName}(${opts.pluginContents}),`
        });
      } else {
        const pluginArrayContent = opts.config.slice(start_of_plugins.index, end_of_plugins.index).trim();
        const isPluginArrayEmpty = pluginArrayContent === "";
        const isPluginArrayEndsWithComma = pluginArrayContent.endsWith(",");
        const needsComma = !isPluginArrayEmpty && !isPluginArrayEndsWithComma;
        new_content = insertContent({
          line: end_of_plugins.line,
          character: end_of_plugins.character,
          content: opts.config,
          insert_content: `${needsComma ? "," : ""}${opts.pluginFunctionName}(${opts.pluginContents})`
        });
      }
      try {
        new_content = await format(new_content);
      } catch (error) {
        console.error(error);
        throw new Error(
          `Failed to generate new auth config during plugin addition phase.`
        );
      }
      return { code: new_content, dependencies: [], envs: [] };
    },
    add_import: async (opts) => {
      let importString = "";
      for (const import_ of opts.imports) {
        if (Array.isArray(import_.variables)) {
          importString += `import { ${import_.variables.map(
            (x) => `${x.asType ? "type " : ""}${x.name}${x.as ? ` as ${x.as}` : ""}`
          ).join(", ")} } from "${import_.path}";
`;
        } else {
          importString += `import ${import_.variables.asType ? "type " : ""}${import_.variables.name}${import_.variables.as ? ` as ${import_.variables.as}` : ""} from "${import_.path}";
`;
        }
      }
      try {
        let new_content = format(importString + opts.config);
        return { code: await new_content, dependencies: [], envs: [] };
      } catch (error) {
        console.error(error);
        throw new Error(
          `Failed to generate new auth config during import addition phase.`
        );
      }
    },
    add_database: async (opts) => {
      const required_envs = [];
      const required_deps = [];
      let database_code_str = "";
      async function add_db({
        db_code,
        dependencies,
        envs,
        imports,
        code_before_betterAuth
      }) {
        if (code_before_betterAuth) {
          let start_of_betterauth2 = getGroupInfo(
            opts.config,
            common_indexes.START_OF_BETTERAUTH,
            {}
          );
          if (!start_of_betterauth2) {
            throw new Error("Couldn't find start of betterAuth() function.");
          }
          opts.config = insertContent({
            line: start_of_betterauth2.line - 1,
            character: 0,
            content: opts.config,
            insert_content: `
${code_before_betterAuth}
`
          });
        }
        const code_gen = await config_generation.add_import({
          config: opts.config,
          imports
        });
        opts.config = code_gen.code;
        database_code_str = db_code;
        required_envs.push(...envs, ...code_gen.envs);
        required_deps.push(...dependencies, ...code_gen.dependencies);
      }
      if (opts.database === "sqlite") {
        await add_db({
          db_code: `new Database(process.env.DATABASE_URL || "database.sqlite")`,
          dependencies: ["better-sqlite3"],
          envs: ["DATABASE_URL"],
          imports: [
            {
              path: "better-sqlite3",
              variables: {
                asType: false,
                name: "Database"
              }
            }
          ]
        });
      } else if (opts.database === "postgres") {
        await add_db({
          db_code: `new Pool({
connectionString: process.env.DATABASE_URL || "postgresql://postgres:password@localhost:5432/database"
})`,
          dependencies: ["pg"],
          envs: ["DATABASE_URL"],
          imports: [
            {
              path: "pg",
              variables: [
                {
                  asType: false,
                  name: "Pool"
                }
              ]
            }
          ]
        });
      } else if (opts.database === "mysql") {
        await add_db({
          db_code: `createPool(process.env.DATABASE_URL!)`,
          dependencies: ["mysql2"],
          envs: ["DATABASE_URL"],
          imports: [
            {
              path: "mysql2/promise",
              variables: [
                {
                  asType: false,
                  name: "createPool"
                }
              ]
            }
          ]
        });
      } else if (opts.database === "mssql") {
        const dialectCode = `new MssqlDialect({
						tarn: {
							...Tarn,
							options: {
							min: 0,
							max: 10,
							},
						},
						tedious: {
							...Tedious,
							connectionFactory: () => new Tedious.Connection({
							authentication: {
								options: {
								password: 'password',
								userName: 'username',
								},
								type: 'default',
							},
							options: {
								database: 'some_db',
								port: 1433,
								trustServerCertificate: true,
							},
							server: 'localhost',
							}),
						},
					})`;
        await add_db({
          code_before_betterAuth: dialectCode,
          db_code: `dialect`,
          dependencies: ["tedious", "tarn", "kysely"],
          envs: ["DATABASE_URL"],
          imports: [
            {
              path: "tedious",
              variables: {
                name: "*",
                as: "Tedious"
              }
            },
            {
              path: "tarn",
              variables: {
                name: "*",
                as: "Tarn"
              }
            },
            {
              path: "kysely",
              variables: [
                {
                  name: "MssqlDialect"
                }
              ]
            }
          ]
        });
      } else if (opts.database === "drizzle:mysql" || opts.database === "drizzle:sqlite" || opts.database === "drizzle:pg") {
        await add_db({
          db_code: `drizzleAdapter(db, {
provider: "${opts.database.replace(
            "drizzle:",
            ""
          )}",
})`,
          dependencies: [""],
          envs: [],
          imports: [
            {
              path: "better-auth/adapters/drizzle",
              variables: [
                {
                  name: "drizzleAdapter"
                }
              ]
            },
            {
              path: "./database.ts",
              variables: [
                {
                  name: "db"
                }
              ]
            }
          ]
        });
      } else if (opts.database === "prisma:mysql" || opts.database === "prisma:sqlite" || opts.database === "prisma:postgresql") {
        await add_db({
          db_code: `prismaAdapter(client, {
provider: "${opts.database.replace(
            "prisma:",
            ""
          )}",
})`,
          dependencies: [`@prisma/client`],
          envs: [],
          code_before_betterAuth: "const client = new PrismaClient();",
          imports: [
            {
              path: "better-auth/adapters/prisma",
              variables: [
                {
                  name: "prismaAdapter"
                }
              ]
            },
            {
              path: "@prisma/client",
              variables: [
                {
                  name: "PrismaClient"
                }
              ]
            }
          ]
        });
      } else if (opts.database === "mongodb") {
        await add_db({
          db_code: `mongodbAdapter(db)`,
          dependencies: ["mongodb"],
          envs: [`DATABASE_URL`],
          code_before_betterAuth: [
            `const client = new MongoClient(process.env.DATABASE_URL || "mongodb://localhost:27017/database");`,
            `const db = client.db();`
          ].join("\n"),
          imports: [
            {
              path: "better-auth/adapters/mongodb",
              variables: [
                {
                  name: "mongodbAdapter"
                }
              ]
            },
            {
              path: "mongodb",
              variables: [
                {
                  name: "MongoClient"
                }
              ]
            }
          ]
        });
      }
      let start_of_betterauth = getGroupInfo(
        opts.config,
        common_indexes.START_OF_BETTERAUTH,
        {}
      );
      if (!start_of_betterauth) {
        throw new Error("Couldn't find start of betterAuth() function.");
      }
      let new_content;
      new_content = insertContent({
        line: start_of_betterauth.line,
        character: start_of_betterauth.character,
        content: opts.config,
        insert_content: `database: ${database_code_str},`
      });
      try {
        new_content = await format(new_content);
        return {
          code: new_content,
          dependencies: required_deps,
          envs: required_envs
        };
      } catch (error) {
        console.error(error);
        throw new Error(
          `Failed to generate new auth config during database addition phase.`
        );
      }
    }
  };
  let new_user_config = await format(current_user_config);
  let total_dependencies = [];
  let total_envs = [];
  if (plugins.length !== 0) {
    const imports = [];
    for await (const plugin of plugins) {
      const existingIndex = imports.findIndex((x) => x.path === plugin.path);
      if (existingIndex !== -1) {
        imports[existingIndex].variables.push({
          name: plugin.name,
          asType: false
        });
      } else {
        imports.push({
          path: plugin.path,
          variables: [
            {
              name: plugin.name,
              asType: false
            }
          ]
        });
      }
    }
    if (imports.length !== 0) {
      const { code, envs, dependencies } = await config_generation.add_import({
        config: new_user_config,
        imports
      });
      total_dependencies.push(...dependencies);
      total_envs.push(...envs);
      new_user_config = code;
    }
  }
  for await (const plugin of plugins) {
    try {
      let pluginContents = "";
      if (plugin.id === "magic-link") {
        pluginContents = `{
sendMagicLink({ email, token, url }, request) {
// Send email with magic link
},
}`;
      } else if (plugin.id === "email-otp") {
        pluginContents = `{
async sendVerificationOTP({ email, otp, type }, request) {
// Send email with OTP
},
}`;
      } else if (plugin.id === "generic-oauth") {
        pluginContents = `{
config: [],
}`;
      } else if (plugin.id === "oidc") {
        pluginContents = `{
loginPage: "/sign-in",
}`;
      }
      const { code, dependencies, envs } = await config_generation.add_plugin({
        config: new_user_config,
        direction_in_plugins_array: plugin.id === "next-cookies" ? "append" : "prepend",
        pluginFunctionName: plugin.name,
        pluginContents
      });
      new_user_config = code;
      total_envs.push(...envs);
      total_dependencies.push(...dependencies);
    } catch (error) {
      spinner.stop(
        `Something went wrong while generating/updating your new auth config file.`,
        1
      );
      logger.error(error.message);
      process.exit(1);
    }
  }
  if (database) {
    try {
      const { code, dependencies, envs } = await config_generation.add_database(
        {
          config: new_user_config,
          database
        }
      );
      new_user_config = code;
      total_dependencies.push(...dependencies);
      total_envs.push(...envs);
    } catch (error) {
      spinner.stop(
        `Something went wrong while generating/updating your new auth config file.`,
        1
      );
      logger.error(error.message);
      process.exit(1);
    }
  }
  return {
    generatedCode: new_user_config,
    dependencies: total_dependencies,
    envs: total_envs
  };
}
function findClosingBracket(content, startIndex, openingBracket, closingBracket) {
  let stack = 0;
  let inString = false;
  let quoteChar = null;
  for (let i = startIndex; i < content.length; i++) {
    const char = content[i];
    if (char === '"' || char === "'" || char === "`") {
      if (!inString) {
        inString = true;
        quoteChar = char;
      } else if (char === quoteChar) {
        inString = false;
        quoteChar = null;
      }
      continue;
    }
    if (!inString) {
      if (char === openingBracket) {
        stack++;
      } else if (char === closingBracket) {
        if (stack === 0) {
          return i;
        }
        stack--;
      }
    }
  }
  return null;
}
function insertContent(params) {
  const { line, character, content, insert_content } = params;
  const lines = content.split("\n");
  if (line < 1 || line > lines.length) {
    throw new Error("Invalid line number");
  }
  const targetLineIndex = line - 1;
  if (character < 0 || character > lines[targetLineIndex].length) {
    throw new Error("Invalid character index");
  }
  const targetLine = lines[targetLineIndex];
  const updatedLine = targetLine.slice(0, character) + insert_content + targetLine.slice(character);
  lines[targetLineIndex] = updatedLine;
  return lines.join("\n");
}
function getGroupInfo(content, commonIndexConfig, additionalFields) {
  if (commonIndexConfig.type === "regex") {
    const { regex, getIndex } = commonIndexConfig;
    const match = regex.exec(content);
    if (match) {
      const matchIndex = match.index;
      const groupIndex = getIndex({ matchIndex, match, additionalFields });
      if (groupIndex === null) return null;
      const position = getPosition(content, groupIndex);
      return {
        line: position.line,
        character: position.character,
        index: groupIndex
      };
    }
    return null;
  } else {
    const { getIndex } = commonIndexConfig;
    const index = getIndex({ content, additionalFields });
    if (index === null) return null;
    const { line, character } = getPosition(content, index);
    return {
      line,
      character,
      index
    };
  }
}
const getPosition = (str, index) => {
  const lines = str.slice(0, index).split("\n");
  return {
    line: lines.length,
    character: lines[lines.length - 1].length
  };
};

function stripJsonComments(jsonString) {
  return jsonString.replace(
    /\\"|"(?:\\"|[^"])*"|(\/\/.*|\/\*[\s\S]*?\*\/)/g,
    (m, g) => g ? "" : m
  ).replace(/,(?=\s*[}\]])/g, "");
}
function getTsconfigInfo(cwd, flatPath) {
  let tsConfigPath;
  if (flatPath) {
    tsConfigPath = flatPath;
  } else {
    tsConfigPath = cwd ? path__default.join(cwd, "tsconfig.json") : path__default.join("tsconfig.json");
  }
  try {
    const text = fs__default.readFileSync(tsConfigPath, "utf-8");
    return JSON.parse(stripJsonComments(text));
  } catch (error) {
    throw error;
  }
}

const supportedDatabases = [
  // Built-in kysely
  "sqlite",
  "mysql",
  "mssql",
  "postgres",
  // Drizzle
  "drizzle:pg",
  "drizzle:mysql",
  "drizzle:sqlite",
  // Prisma
  "prisma:postgresql",
  "prisma:mysql",
  "prisma:sqlite",
  // Mongo
  "mongodb"
];
const supportedPlugins = [
  {
    id: "two-factor",
    name: "twoFactor",
    path: `better-auth/plugins`,
    clientName: "twoFactorClient",
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "username",
    name: "username",
    clientName: "usernameClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "anonymous",
    name: "anonymous",
    clientName: "anonymousClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "phone-number",
    name: "phoneNumber",
    clientName: "phoneNumberClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "magic-link",
    name: "magicLink",
    clientName: "magicLinkClient",
    clientPath: "better-auth/client/plugins",
    path: `better-auth/plugins`
  },
  {
    id: "email-otp",
    name: "emailOTP",
    clientName: "emailOTPClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "passkey",
    name: "passkey",
    clientName: "passkeyClient",
    path: `better-auth/plugins/passkey`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "generic-oauth",
    name: "genericOAuth",
    clientName: "genericOAuthClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "one-tap",
    name: "oneTap",
    clientName: "oneTapClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "api-key",
    name: "apiKey",
    clientName: "apiKeyClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "admin",
    name: "admin",
    clientName: "adminClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "organization",
    name: "organization",
    clientName: "organizationClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "oidc",
    name: "oidcProvider",
    clientName: "oidcClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "sso",
    name: "sso",
    clientName: "ssoClient",
    path: `better-auth/plugins/sso`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "bearer",
    name: "bearer",
    clientName: void 0,
    path: `better-auth/plugins`,
    clientPath: void 0
  },
  {
    id: "multi-session",
    name: "multiSession",
    clientName: "multiSessionClient",
    path: `better-auth/plugins`,
    clientPath: "better-auth/client/plugins"
  },
  {
    id: "oauth-proxy",
    name: "oAuthProxy",
    clientName: void 0,
    path: `better-auth/plugins`,
    clientPath: void 0
  },
  {
    id: "open-api",
    name: "openAPI",
    clientName: void 0,
    path: `better-auth/plugins`,
    clientPath: void 0
  },
  {
    id: "jwt",
    name: "jwt",
    clientName: void 0,
    clientPath: void 0,
    path: `better-auth/plugins`
  },
  {
    id: "next-cookies",
    name: "nextCookies",
    clientPath: void 0,
    clientName: void 0,
    path: `better-auth/next-js`
  }
];
const defaultFormatOptions = {
  trailingComma: "all",
  useTabs: false,
  tabWidth: 4
};
const getDefaultAuthConfig = async ({ appName }) => await format(
  [
    "import { betterAuth } from 'better-auth';",
    "",
    "export const auth = betterAuth({",
    appName ? `appName: "${appName}",` : "",
    "plugins: [],",
    "});"
  ].join("\n"),
  {
    filepath: "auth.ts",
    ...defaultFormatOptions
  }
);
const getDefaultAuthClientConfig = async ({
  auth_config_path,
  framework,
  clientPlugins
}) => {
  function groupImportVariables() {
    const result = [
      {
        path: "better-auth/client/plugins",
        variables: [{ name: "inferAdditionalFields" }]
      }
    ];
    for (const plugin of clientPlugins) {
      for (const import_ of plugin.imports) {
        if (Array.isArray(import_.variables)) {
          for (const variable of import_.variables) {
            const existingIndex = result.findIndex(
              (x) => x.path === import_.path
            );
            if (existingIndex !== -1) {
              const vars = result[existingIndex].variables;
              if (Array.isArray(vars)) {
                vars.push(variable);
              } else {
                result[existingIndex].variables = [vars, variable];
              }
            } else {
              result.push({
                path: import_.path,
                variables: [variable]
              });
            }
          }
        } else {
          const existingIndex = result.findIndex(
            (x) => x.path === import_.path
          );
          if (existingIndex !== -1) {
            const vars = result[existingIndex].variables;
            if (Array.isArray(vars)) {
              vars.push(import_.variables);
            } else {
              result[existingIndex].variables = [vars, import_.variables];
            }
          } else {
            result.push({
              path: import_.path,
              variables: [import_.variables]
            });
          }
        }
      }
    }
    return result;
  }
  let imports = groupImportVariables();
  let importString = "";
  for (const import_ of imports) {
    if (Array.isArray(import_.variables)) {
      importString += `import { ${import_.variables.map(
        (x) => `${x.asType ? "type " : ""}${x.name}${x.as ? ` as ${x.as}` : ""}`
      ).join(", ")} } from "${import_.path}";
`;
    } else {
      importString += `import ${import_.variables.asType ? "type " : ""}${import_.variables.name}${import_.variables.as ? ` as ${import_.variables.as}` : ""} from "${import_.path}";
`;
    }
  }
  return await format(
    [
      `import { createAuthClient } from "better-auth/${framework === "nextjs" ? "react" : framework === "vanilla" ? "client" : framework}";`,
      `import type { auth } from "${auth_config_path}";`,
      importString,
      ``,
      `export const authClient = createAuthClient({`,
      `baseURL: "http://localhost:3000",`,
      `plugins: [inferAdditionalFields<typeof auth>(),${clientPlugins.map((x) => `${x.name}(${x.contents})`).join(", ")}],`,
      `});`
    ].join("\n"),
    {
      filepath: "auth-client.ts",
      ...defaultFormatOptions
    }
  );
};
const optionsSchema = z.object({
  cwd: z.string(),
  config: z.string().optional(),
  database: z.enum(supportedDatabases).optional(),
  "skip-db": z.boolean().optional(),
  "skip-plugins": z.boolean().optional(),
  "package-manager": z.string().optional(),
  tsconfig: z.string().optional()
});
const outroText = `\u{1F973} All Done, Happy Hacking!`;
async function initAction(opts) {
  console.log();
  intro("\u{1F44B} Initializing Better Auth");
  const options = optionsSchema.parse(opts);
  const cwd = path__default.resolve(options.cwd);
  let packageManagerPreference = void 0;
  let config_path = "";
  let framework = "vanilla";
  const format$1 = async (code) => await format(code, {
    filepath: config_path,
    ...defaultFormatOptions
  });
  let packageInfo;
  try {
    packageInfo = getPackageInfo(cwd);
  } catch (error) {
    log.error(`\u274C Couldn't read your package.json file. (dir: ${cwd})`);
    log.error(JSON.stringify(error, null, 2));
    process.exit(1);
  }
  const envFiles = await getEnvFiles(cwd);
  if (!envFiles.length) {
    outro("\u274C No .env files found. Please create an env file first.");
    process.exit(0);
  }
  let targetEnvFile;
  if (envFiles.includes(".env")) targetEnvFile = ".env";
  else if (envFiles.includes(".env.local")) targetEnvFile = ".env.local";
  else if (envFiles.includes(".env.development"))
    targetEnvFile = ".env.development";
  else if (envFiles.length === 1) targetEnvFile = envFiles[0];
  else targetEnvFile = "none";
  let tsconfigInfo;
  try {
    const tsconfigPath = options.tsconfig !== void 0 ? path__default.resolve(cwd, options.tsconfig) : path__default.join(cwd, "tsconfig.json");
    tsconfigInfo = await getTsconfigInfo(cwd, tsconfigPath);
  } catch (error) {
    log.error(`\u274C Couldn't read your tsconfig.json file. (dir: ${cwd})`);
    console.error(error);
    process.exit(1);
  }
  if (!("compilerOptions" in tsconfigInfo && "strict" in tsconfigInfo.compilerOptions && tsconfigInfo.compilerOptions.strict === true)) {
    log.warn(
      `Better Auth requires your tsconfig.json to have "compilerOptions.strict" set to true.`
    );
    const shouldAdd = await confirm({
      message: `Would you like us to set ${chalk.bold(
        `strict`
      )} to ${chalk.bold(`true`)}?`
    });
    if (isCancel(shouldAdd)) {
      cancel(`\u270B Operation cancelled.`);
      process.exit(0);
    }
    if (shouldAdd) {
      try {
        await fs$1.writeFile(
          path__default.join(cwd, "tsconfig.json"),
          await format(
            JSON.stringify(
              Object.assign(tsconfigInfo, {
                compilerOptions: {
                  strict: true
                }
              })
            ),
            { filepath: "tsconfig.json", ...defaultFormatOptions }
          ),
          "utf-8"
        );
        log.success(`\u{1F680} tsconfig.json successfully updated!`);
      } catch (error) {
        log.error(
          `Failed to add "compilerOptions.strict" to your tsconfig.json file.`
        );
        console.error(error);
        process.exit(1);
      }
    }
  }
  const s = spinner({ indicator: "dots" });
  s.start(`Checking better-auth installation`);
  let latest_betterauth_version;
  try {
    latest_betterauth_version = await getLatestNpmVersion("better-auth");
  } catch (error) {
    log.error(`\u274C Couldn't get latest version of better-auth.`);
    console.error(error);
    process.exit(1);
  }
  if (!packageInfo.dependencies || !Object.keys(packageInfo.dependencies).includes("better-auth")) {
    s.stop("Finished fetching latest version of better-auth.");
    const s2 = spinner({ indicator: "dots" });
    const shouldInstallBetterAuthDep = await confirm({
      message: `Would you like to install Better Auth?`
    });
    if (isCancel(shouldInstallBetterAuthDep)) {
      cancel(`\u270B Operation cancelled.`);
      process.exit(0);
    }
    if (packageManagerPreference === void 0) {
      packageManagerPreference = await getPackageManager$1();
    }
    if (shouldInstallBetterAuthDep) {
      s2.start(
        `Installing Better Auth using ${chalk.bold(packageManagerPreference)}`
      );
      try {
        const start = Date.now();
        await installDependencies({
          dependencies: ["better-auth@latest"],
          packageManager: packageManagerPreference,
          cwd
        });
        s2.stop(
          `Better Auth installed ${chalk.greenBright(
            `successfully`
          )}! ${chalk.gray(`(${formatMilliseconds(Date.now() - start)})`)}`
        );
      } catch (error) {
        s2.stop(`Failed to install Better Auth:`);
        console.error(error);
        process.exit(1);
      }
    }
  } else if (packageInfo.dependencies["better-auth"] !== "workspace:*" && semver.lt(
    semver.coerce(packageInfo.dependencies["better-auth"])?.toString(),
    semver.clean(latest_betterauth_version)
  )) {
    s.stop("Finished fetching latest version of better-auth.");
    const shouldInstallBetterAuthDep = await confirm({
      message: `Your current Better Auth dependency is out-of-date. Would you like to update it? (${chalk.bold(
        packageInfo.dependencies["better-auth"]
      )} \u2192 ${chalk.bold(`v${latest_betterauth_version}`)})`
    });
    if (isCancel(shouldInstallBetterAuthDep)) {
      cancel(`\u270B Operation cancelled.`);
      process.exit(0);
    }
    if (shouldInstallBetterAuthDep) {
      if (packageManagerPreference === void 0) {
        packageManagerPreference = await getPackageManager$1();
      }
      const s2 = spinner({ indicator: "dots" });
      s2.start(
        `Updating Better Auth using ${chalk.bold(packageManagerPreference)}`
      );
      try {
        const start = Date.now();
        await installDependencies({
          dependencies: ["better-auth@latest"],
          packageManager: packageManagerPreference,
          cwd
        });
        s2.stop(
          `Better Auth updated ${chalk.greenBright(
            `successfully`
          )}! ${chalk.gray(`(${formatMilliseconds(Date.now() - start)})`)}`
        );
      } catch (error) {
        s2.stop(`Failed to update Better Auth:`);
        log.error(error.message);
        process.exit(1);
      }
    }
  } else {
    s.stop(`Better Auth dependencies are ${chalk.greenBright(`up to date`)}!`);
  }
  const packageJson = getPackageInfo(cwd);
  let appName;
  if (!packageJson.name) {
    const newAppName = await text({
      message: "What is the name of your application?"
    });
    if (isCancel(newAppName)) {
      cancel("\u270B Operation cancelled.");
      process.exit(0);
    }
    appName = newAppName;
  } else {
    appName = packageJson.name;
  }
  let possiblePaths = ["auth.ts", "auth.tsx", "auth.js", "auth.jsx"];
  possiblePaths = [
    ...possiblePaths,
    ...possiblePaths.map((it) => `lib/server/${it}`),
    ...possiblePaths.map((it) => `server/${it}`),
    ...possiblePaths.map((it) => `lib/${it}`),
    ...possiblePaths.map((it) => `utils/${it}`)
  ];
  possiblePaths = [
    ...possiblePaths,
    ...possiblePaths.map((it) => `src/${it}`),
    ...possiblePaths.map((it) => `app/${it}`)
  ];
  if (options.config) {
    config_path = path__default.join(cwd, options.config);
  } else {
    for (const possiblePath of possiblePaths) {
      const doesExist = existsSync(path__default.join(cwd, possiblePath));
      if (doesExist) {
        config_path = path__default.join(cwd, possiblePath);
        break;
      }
    }
  }
  let current_user_config = "";
  let database = null;
  let add_plugins = [];
  if (!config_path) {
    const shouldCreateAuthConfig = await select({
      message: `Would you like to create an auth config file?`,
      options: [
        { label: "Yes", value: "yes" },
        { label: "No", value: "no" }
      ]
    });
    if (isCancel(shouldCreateAuthConfig)) {
      cancel(`\u270B Operation cancelled.`);
      process.exit(0);
    }
    if (shouldCreateAuthConfig === "yes") {
      const shouldSetupDb = await confirm({
        message: `Would you like to set up your ${chalk.bold(`database`)}?`,
        initialValue: true
      });
      if (isCancel(shouldSetupDb)) {
        cancel(`\u270B Operating cancelled.`);
        process.exit(0);
      }
      if (shouldSetupDb) {
        const prompted_database = await select({
          message: "Choose a Database Dialect",
          options: supportedDatabases.map((it) => ({ value: it, label: it }))
        });
        if (isCancel(prompted_database)) {
          cancel(`\u270B Operating cancelled.`);
          process.exit(0);
        }
        database = prompted_database;
      }
      if (options["skip-plugins"] !== false) {
        const shouldSetupPlugins = await confirm({
          message: `Would you like to set up ${chalk.bold(`plugins`)}?`
        });
        if (isCancel(shouldSetupPlugins)) {
          cancel(`\u270B Operating cancelled.`);
          process.exit(0);
        }
        if (shouldSetupPlugins) {
          const prompted_plugins = await multiselect({
            message: "Select your new plugins",
            options: supportedPlugins.filter((x) => x.id !== "next-cookies").map((x) => ({ value: x.id, label: x.id })),
            required: false
          });
          if (isCancel(prompted_plugins)) {
            cancel(`\u270B Operating cancelled.`);
            process.exit(0);
          }
          add_plugins = prompted_plugins.map(
            (x) => supportedPlugins.find((y) => y.id === x)
          );
          const possible_next_config_paths = [
            "next.config.js",
            "next.config.ts",
            "next.config.mjs",
            ".next/server/next.config.js",
            ".next/server/next.config.ts",
            ".next/server/next.config.mjs"
          ];
          for (const possible_next_config_path of possible_next_config_paths) {
            if (existsSync(path__default.join(cwd, possible_next_config_path))) {
              framework = "nextjs";
              break;
            }
          }
          if (framework === "nextjs") {
            const result = await confirm({
              message: `It looks like you're using NextJS. Do you want to add the next-cookies plugin? ${chalk.bold(
                `(Recommended)`
              )}`
            });
            if (isCancel(result)) {
              cancel(`\u270B Operating cancelled.`);
              process.exit(0);
            }
            if (result) {
              add_plugins.push(
                supportedPlugins.find((x) => x.id === "next-cookies")
              );
            }
          }
        }
      }
      const filePath = path__default.join(cwd, "auth.ts");
      config_path = filePath;
      log.info(`Creating auth config file: ${filePath}`);
      try {
        current_user_config = await getDefaultAuthConfig({
          appName
        });
        const { dependencies, envs, generatedCode } = await generateAuthConfig({
          current_user_config,
          format: format$1,
          //@ts-expect-error
          s,
          plugins: add_plugins,
          database
        });
        current_user_config = generatedCode;
        await fs$1.writeFile(filePath, current_user_config);
        config_path = filePath;
        log.success(`\u{1F680} Auth config file successfully created!`);
        if (envs.length !== 0) {
          log.info(
            `There are ${envs.length} environment variables for your database of choice.`
          );
          const shouldUpdateEnvs = await confirm({
            message: `Would you like us to update your ENV files?`
          });
          if (isCancel(shouldUpdateEnvs)) {
            cancel("\u270B Operation cancelled.");
            process.exit(0);
          }
          if (shouldUpdateEnvs) {
            const filesToUpdate = await multiselect({
              message: "Select the .env files you want to update",
              options: envFiles.map((x) => ({
                value: path__default.join(cwd, x),
                label: x
              })),
              required: false
            });
            if (isCancel(filesToUpdate)) {
              cancel("\u270B Operation cancelled.");
              process.exit(0);
            }
            if (filesToUpdate.length === 0) {
              log.info("No .env files to update. Skipping...");
            } else {
              try {
                await updateEnvs({
                  files: filesToUpdate,
                  envs,
                  isCommented: true
                });
              } catch (error) {
                log.error(`Failed to update .env files:`);
                log.error(JSON.stringify(error, null, 2));
                process.exit(1);
              }
              log.success(`\u{1F680} ENV files successfully updated!`);
            }
          }
        }
        if (dependencies.length !== 0) {
          log.info(
            `There are ${dependencies.length} dependencies to install. (${dependencies.map((x) => chalk.green(x)).join(", ")})`
          );
          const shouldInstallDeps = await confirm({
            message: `Would you like us to install dependencies?`
          });
          if (isCancel(shouldInstallDeps)) {
            cancel("\u270B Operation cancelled.");
            process.exit(0);
          }
          if (shouldInstallDeps) {
            const s2 = spinner({ indicator: "dots" });
            if (packageManagerPreference === void 0) {
              packageManagerPreference = await getPackageManager$1();
            }
            s2.start(
              `Installing dependencies using ${chalk.bold(
                packageManagerPreference
              )}...`
            );
            try {
              const start = Date.now();
              await installDependencies({
                dependencies,
                packageManager: packageManagerPreference,
                cwd
              });
              s2.stop(
                `Dependencies installed ${chalk.greenBright(
                  `successfully`
                )} ${chalk.gray(
                  `(${formatMilliseconds(Date.now() - start)})`
                )}`
              );
            } catch (error) {
              s2.stop(
                `Failed to install dependencies using ${packageManagerPreference}:`
              );
              log.error(error.message);
              process.exit(1);
            }
          }
        }
      } catch (error) {
        log.error(`Failed to create auth config file: ${filePath}`);
        console.error(error);
        process.exit(1);
      }
    } else if (shouldCreateAuthConfig === "no") {
      log.info(`Skipping auth config file creation.`);
    }
  } else {
    log.message();
    log.success(`Found auth config file. ${chalk.gray(`(${config_path})`)}`);
    log.message();
  }
  let possibleClientPaths = [
    "auth-client.ts",
    "auth-client.tsx",
    "auth-client.js",
    "auth-client.jsx",
    "client.ts",
    "client.tsx",
    "client.js",
    "client.jsx"
  ];
  possibleClientPaths = [
    ...possibleClientPaths,
    ...possibleClientPaths.map((it) => `lib/server/${it}`),
    ...possibleClientPaths.map((it) => `server/${it}`),
    ...possibleClientPaths.map((it) => `lib/${it}`),
    ...possibleClientPaths.map((it) => `utils/${it}`)
  ];
  possibleClientPaths = [
    ...possibleClientPaths,
    ...possibleClientPaths.map((it) => `src/${it}`),
    ...possibleClientPaths.map((it) => `app/${it}`)
  ];
  let authClientConfigPath = null;
  for (const possiblePath of possibleClientPaths) {
    const doesExist = existsSync(path__default.join(cwd, possiblePath));
    if (doesExist) {
      authClientConfigPath = path__default.join(cwd, possiblePath);
      break;
    }
  }
  if (!authClientConfigPath) {
    const choice = await select({
      message: `Would you like to create an auth client config file?`,
      options: [
        { label: "Yes", value: "yes" },
        { label: "No", value: "no" }
      ]
    });
    if (isCancel(choice)) {
      cancel(`\u270B Operation cancelled.`);
      process.exit(0);
    }
    if (choice === "yes") {
      authClientConfigPath = path__default.join(cwd, "auth-client.ts");
      log.info(`Creating auth client config file: ${authClientConfigPath}`);
      try {
        let contents = await getDefaultAuthClientConfig({
          auth_config_path: ("./" + path__default.join(config_path.replace(cwd, ""))).replace(".//", "./"),
          clientPlugins: add_plugins.filter((x) => x.clientName).map((plugin) => {
            let contents2 = "";
            if (plugin.id === "one-tap") {
              contents2 = `{ clientId: "MY_CLIENT_ID" }`;
            }
            return {
              contents: contents2,
              id: plugin.id,
              name: plugin.clientName,
              imports: [
                {
                  path: "better-auth/client/plugins",
                  variables: [{ name: plugin.clientName }]
                }
              ]
            };
          }),
          framework
        });
        await fs$1.writeFile(authClientConfigPath, contents);
        log.success(`\u{1F680} Auth client config file successfully created!`);
      } catch (error) {
        log.error(
          `Failed to create auth client config file: ${authClientConfigPath}`
        );
        log.error(JSON.stringify(error, null, 2));
        process.exit(1);
      }
    } else if (choice === "no") {
      log.info(`Skipping auth client config file creation.`);
    }
  } else {
    log.success(
      `Found auth client config file. ${chalk.gray(
        `(${authClientConfigPath})`
      )}`
    );
  }
  if (targetEnvFile !== "none") {
    try {
      const fileContents = await fs$1.readFile(
        path__default.join(cwd, targetEnvFile),
        "utf8"
      );
      const parsed = parse(fileContents);
      let isMissingSecret = false;
      let isMissingUrl = false;
      if (parsed.BETTER_AUTH_SECRET === void 0) isMissingSecret = true;
      if (parsed.BETTER_AUTH_URL === void 0) isMissingUrl = true;
      if (isMissingSecret || isMissingUrl) {
        let txt = "";
        if (isMissingSecret && !isMissingUrl)
          txt = chalk.bold(`BETTER_AUTH_SECRET`);
        else if (!isMissingSecret && isMissingUrl)
          txt = chalk.bold(`BETTER_AUTH_URL`);
        else
          txt = chalk.bold.underline(`BETTER_AUTH_SECRET`) + ` and ` + chalk.bold.underline(`BETTER_AUTH_URL`);
        log.warn(`Missing ${txt} in ${targetEnvFile}`);
        const shouldAdd = await select({
          message: `Do you want to add ${txt} to ${targetEnvFile}?`,
          options: [
            { label: "Yes", value: "yes" },
            { label: "No", value: "no" },
            { label: "Choose other file(s)", value: "other" }
          ]
        });
        if (isCancel(shouldAdd)) {
          cancel(`\u270B Operation cancelled.`);
          process.exit(0);
        }
        let envs = [];
        if (isMissingSecret) {
          envs.push("BETTER_AUTH_SECRET");
        }
        if (isMissingUrl) {
          envs.push("BETTER_AUTH_URL");
        }
        if (shouldAdd === "yes") {
          try {
            await updateEnvs({
              files: [path__default.join(cwd, targetEnvFile)],
              envs,
              isCommented: false
            });
          } catch (error) {
            log.error(`Failed to add ENV variables to ${targetEnvFile}`);
            log.error(JSON.stringify(error, null, 2));
            process.exit(1);
          }
          log.success(`\u{1F680} ENV variables successfully added!`);
          if (isMissingUrl) {
            log.info(
              `Be sure to update your BETTER_AUTH_URL according to your app's needs.`
            );
          }
        } else if (shouldAdd === "no") {
          log.info(`Skipping ENV step.`);
        } else if (shouldAdd === "other") {
          if (!envFiles.length) {
            cancel("No env files found. Please create an env file first.");
            process.exit(0);
          }
          const envFilesToUpdate = await multiselect({
            message: "Select the .env files you want to update",
            options: envFiles.map((x) => ({
              value: path__default.join(cwd, x),
              label: x
            })),
            required: false
          });
          if (isCancel(envFilesToUpdate)) {
            cancel("\u270B Operation cancelled.");
            process.exit(0);
          }
          if (envFilesToUpdate.length === 0) {
            log.info("No .env files to update. Skipping...");
          } else {
            try {
              await updateEnvs({
                files: envFilesToUpdate,
                envs,
                isCommented: false
              });
            } catch (error) {
              log.error(`Failed to update .env files:`);
              log.error(JSON.stringify(error, null, 2));
              process.exit(1);
            }
            log.success(`\u{1F680} ENV files successfully updated!`);
          }
        }
      }
    } catch (error) {
    }
  }
  outro(outroText);
  console.log();
  process.exit(0);
}
const init = new Command("init").option("-c, --cwd <cwd>", "The working directory.", process.cwd()).option(
  "--config <config>",
  "The path to the auth configuration file. defaults to the first `auth.ts` file found."
).option("--tsconfig <tsconfig>", "The path to the tsconfig file.").option("--skip-db", "Skip the database setup.").option("--skip-plugins", "Skip the plugins setup.").option(
  "--package-manager <package-manager>",
  "The package manager you want to use."
).action(initAction);
async function getLatestNpmVersion(packageName) {
  try {
    const response = await fetch(`https://registry.npmjs.org/${packageName}`);
    if (!response.ok) {
      throw new Error(`Package not found: ${response.statusText}`);
    }
    const data = await response.json();
    return data["dist-tags"].latest;
  } catch (error) {
    throw error?.message;
  }
}
async function getPackageManager$1() {
  const { hasBun, hasPnpm } = await checkPackageManagers();
  if (!hasBun && !hasPnpm) return "npm";
  const packageManagerOptions = [];
  if (hasPnpm) {
    packageManagerOptions.push({
      value: "pnpm",
      label: "pnpm",
      hint: "recommended"
    });
  }
  if (hasBun) {
    packageManagerOptions.push({
      value: "bun",
      label: "bun"
    });
  }
  packageManagerOptions.push({
    value: "npm",
    hint: "not recommended"
  });
  let packageManager = await select({
    message: "Choose a package manager",
    options: packageManagerOptions
  });
  if (isCancel(packageManager)) {
    cancel(`Operation cancelled.`);
    process.exit(0);
  }
  return packageManager;
}
async function getEnvFiles(cwd) {
  const files = await fs$1.readdir(cwd);
  return files.filter((x) => x.startsWith(".env"));
}
async function updateEnvs({
  envs,
  files,
  isCommented
}) {
  let previouslyGeneratedSecret = null;
  for (const file of files) {
    const content = await fs$1.readFile(file, "utf8");
    const lines = content.split("\n");
    const newLines = envs.map(
      (x) => `${isCommented ? "# " : ""}${x}=${getEnvDescription(x) ?? `"some_value"`}`
    );
    newLines.push("");
    newLines.push(...lines);
    await fs$1.writeFile(file, newLines.join("\n"), "utf8");
  }
  function getEnvDescription(env) {
    if (env === "DATABASE_HOST") {
      return `"The host of your database"`;
    }
    if (env === "DATABASE_PORT") {
      return `"The port of your database"`;
    }
    if (env === "DATABASE_USER") {
      return `"The username of your database"`;
    }
    if (env === "DATABASE_PASSWORD") {
      return `"The password of your database"`;
    }
    if (env === "DATABASE_NAME") {
      return `"The name of your database"`;
    }
    if (env === "DATABASE_URL") {
      return `"The URL of your database"`;
    }
    if (env === "BETTER_AUTH_SECRET") {
      previouslyGeneratedSecret = previouslyGeneratedSecret ?? generateSecretHash();
      return `"${previouslyGeneratedSecret}"`;
    }
    if (env === "BETTER_AUTH_URL") {
      return `"http://localhost:3000" # Your APP URL`;
    }
  }
}

function addSvelteKitEnvModules(aliases, cwd) {
  const workingDir = process.cwd();
  aliases["$env/dynamic/private"] = createDataUriModule(
    createDynamicEnvModule()
  );
  aliases["$env/dynamic/public"] = createDataUriModule(
    createDynamicEnvModule()
  );
  aliases["$env/static/private"] = createDataUriModule(
    createStaticEnvModule(filterPrivateEnv("PUBLIC_", ""))
  );
  aliases["$env/static/public"] = createDataUriModule(
    createStaticEnvModule(filterPublicEnv("PUBLIC_", ""))
  );
  const svelteKitAliases = getSvelteKitPathAliases(workingDir);
  Object.assign(aliases, svelteKitAliases);
}
function getSvelteKitPathAliases(cwd) {
  const aliases = {};
  const packageJsonPath = path__default.join(cwd, "package.json");
  const svelteConfigPath = path__default.join(cwd, "svelte.config.js");
  const svelteConfigTsPath = path__default.join(cwd, "svelte.config.ts");
  let isSvelteKitProject = false;
  if (fs__default.existsSync(packageJsonPath)) {
    try {
      const packageJson = JSON.parse(fs__default.readFileSync(packageJsonPath, "utf-8"));
      const deps = {
        ...packageJson.dependencies,
        ...packageJson.devDependencies
      };
      isSvelteKitProject = !!deps["@sveltejs/kit"];
    } catch {
    }
  }
  if (!isSvelteKitProject) {
    isSvelteKitProject = fs__default.existsSync(svelteConfigPath) || fs__default.existsSync(svelteConfigTsPath);
  }
  if (!isSvelteKitProject) {
    return aliases;
  }
  const libPaths = [path__default.join(cwd, "src", "lib"), path__default.join(cwd, "lib")];
  for (const libPath of libPaths) {
    if (fs__default.existsSync(libPath)) {
      aliases["$lib"] = libPath;
      const commonSubPaths = ["server", "utils", "components", "stores"];
      for (const subPath of commonSubPaths) {
        const subDir = path__default.join(libPath, subPath);
        if (fs__default.existsSync(subDir)) {
          aliases[`$lib/${subPath}`] = subDir;
        }
      }
      break;
    }
  }
  aliases["$app/server"] = createDataUriModule(createAppServerModule());
  const customAliases = getSvelteConfigAliases(cwd);
  Object.assign(aliases, customAliases);
  return aliases;
}
function getSvelteConfigAliases(cwd) {
  const aliases = {};
  const configPaths = [
    path__default.join(cwd, "svelte.config.js"),
    path__default.join(cwd, "svelte.config.ts")
  ];
  for (const configPath of configPaths) {
    if (fs__default.existsSync(configPath)) {
      try {
        const content = fs__default.readFileSync(configPath, "utf-8");
        const aliasMatch = content.match(/alias\s*:\s*\{([^}]+)\}/);
        if (aliasMatch && aliasMatch[1]) {
          const aliasContent = aliasMatch[1];
          const aliasMatches = aliasContent.matchAll(
            /['"`](\$[^'"`]+)['"`]\s*:\s*['"`]([^'"`]+)['"`]/g
          );
          for (const match of aliasMatches) {
            const [, alias, target] = match;
            if (alias && target) {
              aliases[alias + "/*"] = path__default.resolve(cwd, target) + "/*";
              aliases[alias] = path__default.resolve(cwd, target);
            }
          }
        }
      } catch {
      }
      break;
    }
  }
  return aliases;
}
function createAppServerModule() {
  return `
// $app/server stub for CLI compatibility
export default {};
// jiti dirty hack: .unknown
`;
}
function createDataUriModule(module) {
  return `data:text/javascript;charset=utf-8,${encodeURIComponent(module)}`;
}
function createStaticEnvModule(env) {
  const declarations = Object.keys(env).filter((k) => validIdentifier.test(k) && !reserved.has(k)).map((k) => `export const ${k} = ${JSON.stringify(env[k])};`);
  return `
  ${declarations.join("\n")}
  // jiti dirty hack: .unknown
  `;
}
function createDynamicEnvModule() {
  return `
  export const env = process.env;
  // jiti dirty hack: .unknown
  `;
}
function filterPrivateEnv(publicPrefix, privatePrefix) {
  return Object.fromEntries(
    Object.entries(process.env).filter(
      ([k]) => k.startsWith(privatePrefix) && (!k.startsWith(publicPrefix))
    )
  );
}
function filterPublicEnv(publicPrefix, privatePrefix) {
  return Object.fromEntries(
    Object.entries(process.env).filter(
      ([k]) => k.startsWith(publicPrefix) && (privatePrefix === "")
    )
  );
}
const validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/;
const reserved = /* @__PURE__ */ new Set([
  "do",
  "if",
  "in",
  "for",
  "let",
  "new",
  "try",
  "var",
  "case",
  "else",
  "enum",
  "eval",
  "null",
  "this",
  "true",
  "void",
  "with",
  "await",
  "break",
  "catch",
  "class",
  "const",
  "false",
  "super",
  "throw",
  "while",
  "yield",
  "delete",
  "export",
  "import",
  "public",
  "return",
  "static",
  "switch",
  "typeof",
  "default",
  "extends",
  "finally",
  "package",
  "private",
  "continue",
  "debugger",
  "function",
  "arguments",
  "interface",
  "protected",
  "implements",
  "instanceof"
]);

let possiblePaths = [
  "auth.ts",
  "auth.tsx",
  "auth.js",
  "auth.jsx",
  "auth.server.js",
  "auth.server.ts"
];
possiblePaths = [
  ...possiblePaths,
  ...possiblePaths.map((it) => `lib/server/${it}`),
  ...possiblePaths.map((it) => `server/${it}`),
  ...possiblePaths.map((it) => `lib/${it}`),
  ...possiblePaths.map((it) => `utils/${it}`)
];
possiblePaths = [
  ...possiblePaths,
  ...possiblePaths.map((it) => `src/${it}`),
  ...possiblePaths.map((it) => `app/${it}`)
];
function resolveReferencePath(configDir, refPath) {
  const resolvedPath = path__default.resolve(configDir, refPath);
  if (refPath.endsWith(".json")) {
    return resolvedPath;
  }
  if (fs__default.existsSync(resolvedPath)) {
    try {
      const stats = fs__default.statSync(resolvedPath);
      if (stats.isFile()) {
        return resolvedPath;
      }
    } catch {
    }
  }
  return path__default.resolve(configDir, refPath, "tsconfig.json");
}
function getPathAliasesRecursive(tsconfigPath, visited = /* @__PURE__ */ new Set()) {
  if (visited.has(tsconfigPath)) {
    return {};
  }
  visited.add(tsconfigPath);
  if (!fs__default.existsSync(tsconfigPath)) {
    logger.warn(`Referenced tsconfig not found: ${tsconfigPath}`);
    return {};
  }
  try {
    const tsConfig = getTsconfigInfo(void 0, tsconfigPath);
    const { paths = {}, baseUrl = "." } = tsConfig.compilerOptions || {};
    const result = {};
    const configDir = path__default.dirname(tsconfigPath);
    const obj = Object.entries(paths);
    for (const [alias, aliasPaths] of obj) {
      for (const aliasedPath of aliasPaths) {
        const resolvedBaseUrl = path__default.resolve(configDir, baseUrl);
        const finalAlias = alias.slice(-1) === "*" ? alias.slice(0, -1) : alias;
        const finalAliasedPath = aliasedPath.slice(-1) === "*" ? aliasedPath.slice(0, -1) : aliasedPath;
        result[finalAlias || ""] = path__default.join(resolvedBaseUrl, finalAliasedPath);
      }
    }
    if (tsConfig.references) {
      for (const ref of tsConfig.references) {
        const refPath = resolveReferencePath(configDir, ref.path);
        const refAliases = getPathAliasesRecursive(refPath, visited);
        for (const [alias, aliasPath] of Object.entries(refAliases)) {
          if (!(alias in result)) {
            result[alias] = aliasPath;
          }
        }
      }
    }
    return result;
  } catch (error) {
    logger.warn(`Error parsing tsconfig at ${tsconfigPath}: ${error}`);
    return {};
  }
}
function getPathAliases(cwd) {
  const tsConfigPath = path__default.join(cwd, "tsconfig.json");
  if (!fs__default.existsSync(tsConfigPath)) {
    return null;
  }
  try {
    const result = getPathAliasesRecursive(tsConfigPath);
    addSvelteKitEnvModules(result);
    return result;
  } catch (error) {
    console.error(error);
    throw new BetterAuthError("Error parsing tsconfig.json");
  }
}
const jitiOptions = (cwd) => {
  const alias = getPathAliases(cwd) || {};
  return {
    transformOptions: {
      babel: {
        presets: [
          [
            babelPresetTypeScript,
            {
              isTSX: true,
              allExtensions: true
            }
          ],
          [babelPresetReact, { runtime: "automatic" }]
        ]
      }
    },
    extensions: [".ts", ".tsx", ".js", ".jsx"],
    alias
  };
};
const isDefaultExport = (object) => {
  return typeof object === "object" && object !== null && !Array.isArray(object) && Object.keys(object).length > 0 && "options" in object;
};
async function getConfig({
  cwd,
  configPath,
  shouldThrowOnError = false
}) {
  try {
    let configFile = null;
    if (configPath) {
      let resolvedPath = path__default.join(cwd, configPath);
      if (existsSync(configPath)) resolvedPath = configPath;
      const { config } = await loadConfig({
        configFile: resolvedPath,
        dotenv: true,
        jitiOptions: jitiOptions(cwd)
      });
      if (!("auth" in config) && !isDefaultExport(config)) {
        if (shouldThrowOnError) {
          throw new Error(
            `Couldn't read your auth config in ${resolvedPath}. Make sure to default export your auth instance or to export as a variable named auth.`
          );
        }
        logger.error(
          `[#better-auth]: Couldn't read your auth config in ${resolvedPath}. Make sure to default export your auth instance or to export as a variable named auth.`
        );
        process.exit(1);
      }
      configFile = "auth" in config ? config.auth?.options : config.options;
    }
    if (!configFile) {
      for (const possiblePath of possiblePaths) {
        try {
          const { config } = await loadConfig({
            configFile: possiblePath,
            jitiOptions: jitiOptions(cwd)
          });
          const hasConfig = Object.keys(config).length > 0;
          if (hasConfig) {
            configFile = config.auth?.options || config.default?.options || null;
            if (!configFile) {
              if (shouldThrowOnError) {
                throw new Error(
                  "Couldn't read your auth config. Make sure to default export your auth instance or to export as a variable named auth."
                );
              }
              logger.error("[#better-auth]: Couldn't read your auth config.");
              console.log("");
              logger.info(
                "[#better-auth]: Make sure to default export your auth instance or to export as a variable named auth."
              );
              process.exit(1);
            }
            break;
          }
        } catch (e) {
          if (typeof e === "object" && e && "message" in e && typeof e.message === "string" && e.message.includes(
            "This module cannot be imported from a Client Component module"
          )) {
            if (shouldThrowOnError) {
              throw new Error(
                `Please remove import 'server-only' from your auth config file temporarily. The CLI cannot resolve the configuration with it included. You can re-add it after running the CLI.`
              );
            }
            logger.error(
              `Please remove import 'server-only' from your auth config file temporarily. The CLI cannot resolve the configuration with it included. You can re-add it after running the CLI.`
            );
            process.exit(1);
          }
          if (shouldThrowOnError) {
            throw e;
          }
          logger.error("[#better-auth]: Couldn't read your auth config.", e);
          process.exit(1);
        }
      }
    }
    return configFile;
  } catch (e) {
    if (typeof e === "object" && e && "message" in e && typeof e.message === "string" && e.message.includes(
      "This module cannot be imported from a Client Component module"
    )) {
      if (shouldThrowOnError) {
        throw new Error(
          `Please remove import 'server-only' from your auth config file temporarily. The CLI cannot resolve the configuration with it included. You can re-add it after running the CLI.`
        );
      }
      logger.error(
        `Please remove import 'server-only' from your auth config file temporarily. The CLI cannot resolve the configuration with it included. You can re-add it after running the CLI.`
      );
      process.exit(1);
    }
    if (shouldThrowOnError) {
      throw e;
    }
    logger.error("Couldn't read your auth config.", e);
    process.exit(1);
  }
}

async function migrateAction(opts) {
  const options = z.object({
    cwd: z.string(),
    config: z.string().optional(),
    y: z.boolean().optional(),
    yes: z.boolean().optional()
  }).parse(opts);
  const cwd = path__default.resolve(options.cwd);
  if (!existsSync(cwd)) {
    logger.error(`The directory "${cwd}" does not exist.`);
    process.exit(1);
  }
  const config = await getConfig({
    cwd,
    configPath: options.config
  });
  if (!config) {
    logger.error(
      "No configuration file found. Add a `auth.ts` file to your project or pass the path to the configuration file using the `--config` flag."
    );
    return;
  }
  const db = await getAdapter(config);
  if (!db) {
    logger.error(
      "Invalid database configuration. Make sure you're not using adapters. Migrate command only works with built-in Kysely adapter."
    );
    process.exit(1);
  }
  if (db.id !== "kysely") {
    if (db.id === "prisma") {
      logger.error(
        "The migrate command only works with the built-in Kysely adapter. For Prisma, run `npx @better-auth/cli generate` to create the schema, then use Prisma\u2019s migrate or push to apply it."
      );
      try {
        const telemetry = await createTelemetry(config);
        await telemetry.publish({
          type: "cli_migrate",
          payload: {
            outcome: "unsupported_adapter",
            adapter: "prisma",
            config: getTelemetryAuthConfig(config)
          }
        });
      } catch {
      }
      process.exit(0);
    }
    if (db.id === "drizzle") {
      logger.error(
        "The migrate command only works with the built-in Kysely adapter. For Drizzle, run `npx @better-auth/cli generate` to create the schema, then use Drizzle\u2019s migrate or push to apply it."
      );
      try {
        const telemetry = await createTelemetry(config);
        await telemetry.publish({
          type: "cli_migrate",
          payload: {
            outcome: "unsupported_adapter",
            adapter: "drizzle",
            config: getTelemetryAuthConfig(config)
          }
        });
      } catch {
      }
      process.exit(0);
    }
    logger.error("Migrate command isn't supported for this adapter.");
    try {
      const telemetry = await createTelemetry(config);
      await telemetry.publish({
        type: "cli_migrate",
        payload: {
          outcome: "unsupported_adapter",
          adapter: db.id,
          config: getTelemetryAuthConfig(config)
        }
      });
    } catch {
    }
    process.exit(1);
  }
  const spinner = yoctoSpinner({ text: "preparing migration..." }).start();
  const { toBeAdded, toBeCreated, runMigrations } = await getMigrations(config);
  if (!toBeAdded.length && !toBeCreated.length) {
    spinner.stop();
    logger.info("\u{1F680} No migrations needed.");
    try {
      const telemetry = await createTelemetry(config);
      await telemetry.publish({
        type: "cli_migrate",
        payload: {
          outcome: "no_changes",
          config: getTelemetryAuthConfig(config)
        }
      });
    } catch {
    }
    process.exit(0);
  }
  spinner.stop();
  logger.info(`\u{1F511} The migration will affect the following:`);
  for (const table of [...toBeCreated, ...toBeAdded]) {
    console.log(
      "->",
      chalk.magenta(Object.keys(table.fields).join(", ")),
      chalk.white("fields on"),
      chalk.yellow(`${table.table}`),
      chalk.white("table.")
    );
  }
  if (options.y) {
    console.warn("WARNING: --y is deprecated. Consider -y or --yes");
    options.yes = true;
  }
  let migrate2 = options.yes;
  if (!migrate2) {
    const response = await prompts({
      type: "confirm",
      name: "migrate",
      message: "Are you sure you want to run these migrations?",
      initial: false
    });
    migrate2 = response.migrate;
  }
  if (!migrate2) {
    logger.info("Migration cancelled.");
    try {
      const telemetry = await createTelemetry(config);
      await telemetry.publish({
        type: "cli_migrate",
        payload: { outcome: "aborted", config: getTelemetryAuthConfig(config) }
      });
    } catch {
    }
    process.exit(0);
  }
  spinner?.start("migrating...");
  await runMigrations();
  spinner.stop();
  logger.info("\u{1F680} migration was completed successfully!");
  try {
    const telemetry = await createTelemetry(config);
    await telemetry.publish({
      type: "cli_migrate",
      payload: { outcome: "migrated", config: getTelemetryAuthConfig(config) }
    });
  } catch {
  }
  process.exit(0);
}
const migrate = new Command("migrate").option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).option(
  "--config <config>",
  "the path to the configuration file. defaults to the first configuration file found."
).option(
  "-y, --yes",
  "automatically accept and run migrations without prompting",
  false
).option("--y", "(deprecated) same as --yes", false).action(migrateAction);

function convertToSnakeCase(str, camelCase) {
  if (camelCase) {
    return str;
  }
  return str.replace(/([A-Z]+)([A-Z][a-z])/g, "$1_$2").replace(/([a-z\d])([A-Z])/g, "$1_$2").toLowerCase();
}
const generateDrizzleSchema = async ({
  options,
  file,
  adapter
}) => {
  const tables = getAuthTables(options);
  const filePath = file || "./auth-schema.ts";
  const databaseType = adapter.options?.provider;
  if (!databaseType) {
    throw new Error(
      `Database provider type is undefined during Drizzle schema generation. Please define a \`provider\` in the Drizzle adapter config. Read more at https://better-auth.com/docs/adapters/drizzle`
    );
  }
  const fileExist = existsSync(filePath);
  let code = generateImport({ databaseType, tables, options });
  for (const tableKey in tables) {
    let getType = function(name, field) {
      if (!databaseType) {
        throw new Error(
          `Database provider type is undefined during Drizzle schema generation. Please define a \`provider\` in the Drizzle adapter config. Read more at https://better-auth.com/docs/adapters/drizzle`
        );
      }
      name = convertToSnakeCase(name, adapter.options?.camelCase);
      if (field.references?.field === "id") {
        if (options.advanced?.database?.useNumberId) {
          if (databaseType === "pg") {
            return `integer('${name}')`;
          } else if (databaseType === "mysql") {
            return `int('${name}')`;
          } else {
            return `integer('${name}')`;
          }
        }
        if (field.references.field) {
          if (databaseType === "mysql") {
            return `varchar('${name}', { length: 36 })`;
          }
        }
        return `text('${name}')`;
      }
      const type = field.type;
      const typeMap = {
        string: {
          sqlite: `text('${name}')`,
          pg: `text('${name}')`,
          mysql: field.unique ? `varchar('${name}', { length: 255 })` : field.references ? `varchar('${name}', { length: 36 })` : `text('${name}')`
        },
        boolean: {
          sqlite: `integer('${name}', { mode: 'boolean' })`,
          pg: `boolean('${name}')`,
          mysql: `boolean('${name}')`
        },
        number: {
          sqlite: `integer('${name}')`,
          pg: field.bigint ? `bigint('${name}', { mode: 'number' })` : `integer('${name}')`,
          mysql: field.bigint ? `bigint('${name}', { mode: 'number' })` : `int('${name}')`
        },
        date: {
          sqlite: `integer('${name}', { mode: 'timestamp_ms' })`,
          pg: `timestamp('${name}')`,
          mysql: `timestamp('${name}', { fsp: 3 })`
        },
        "number[]": {
          sqlite: `integer('${name}').array()`,
          pg: field.bigint ? `bigint('${name}', { mode: 'number' }).array()` : `integer('${name}').array()`,
          mysql: field.bigint ? `bigint('${name}', { mode: 'number' }).array()` : `int('${name}').array()`
        },
        "string[]": {
          sqlite: `text('${name}').array()`,
          pg: `text('${name}').array()`,
          mysql: `text('${name}').array()`
        },
        json: {
          sqlite: `text('${name}')`,
          pg: `jsonb('${name}')`,
          mysql: `json('${name}')`
        }
      };
      return typeMap[type][databaseType];
    };
    const table = tables[tableKey];
    const modelName = getModelName(table.modelName, adapter.options);
    const fields = table.fields;
    let id = "";
    if (options.advanced?.database?.useNumberId) {
      if (databaseType === "pg") {
        id = `serial("id").primaryKey()`;
      } else if (databaseType === "sqlite") {
        id = `integer("id", { mode: "number" }).primaryKey({ autoIncrement: true })`;
      } else {
        id = `int("id").autoincrement().primaryKey()`;
      }
    } else {
      if (databaseType === "mysql") {
        id = `varchar('id', { length: 36 }).primaryKey()`;
      } else if (databaseType === "pg") {
        id = `text('id').primaryKey()`;
      } else {
        id = `text('id').primaryKey()`;
      }
    }
    const schema = `export const ${modelName} = ${databaseType}Table("${convertToSnakeCase(
      modelName,
      adapter.options?.camelCase
    )}", {
					id: ${id},
					${Object.keys(fields).map((field) => {
      const attr = fields[field];
      const fieldName = attr.fieldName || field;
      let type = getType(fieldName, attr);
      if (attr.defaultValue !== null && typeof attr.defaultValue !== "undefined") {
        if (typeof attr.defaultValue === "function") {
          if (attr.type === "date" && attr.defaultValue.toString().includes("new Date()")) {
            if (databaseType === "sqlite") {
              type += `.default(sql\`(cast(unixepoch('subsecond') * 1000 as integer))\`)`;
            } else {
              type += `.defaultNow()`;
            }
          } else {
            type += `.$defaultFn(${attr.defaultValue})`;
          }
        } else if (typeof attr.defaultValue === "string") {
          type += `.default("${attr.defaultValue}")`;
        } else {
          type += `.default(${attr.defaultValue})`;
        }
      }
      if (attr.onUpdate && attr.type === "date") {
        if (typeof attr.onUpdate === "function") {
          type += `.$onUpdate(${attr.onUpdate})`;
        }
      }
      return `${fieldName}: ${type}${attr.required ? ".notNull()" : ""}${attr.unique ? ".unique()" : ""}${attr.references ? `.references(()=> ${getModelName(
        tables[attr.references.model]?.modelName || attr.references.model,
        adapter.options
      )}.${fields[attr.references.field]?.fieldName || attr.references.field}, { onDelete: '${attr.references.onDelete || "cascade"}' })` : ""}`;
    }).join(",\n ")}
				});`;
    code += `
${schema}
`;
  }
  const formattedCode = await prettier.format(code, {
    parser: "typescript"
  });
  return {
    code: formattedCode,
    fileName: filePath,
    overwrite: fileExist
  };
};
function generateImport({
  databaseType,
  tables,
  options
}) {
  const rootImports = [];
  const coreImports = [];
  let hasBigint = false;
  let hasJson = false;
  for (const table of Object.values(tables)) {
    for (const field of Object.values(table.fields)) {
      if (field.bigint) hasBigint = true;
      if (field.type === "json") hasJson = true;
    }
    if (hasJson && hasBigint) break;
  }
  const useNumberId = options.advanced?.database?.useNumberId;
  coreImports.push(`${databaseType}Table`);
  coreImports.push(
    databaseType === "mysql" ? "varchar, text" : databaseType === "pg" ? "text" : "text"
  );
  coreImports.push(
    hasBigint ? databaseType !== "sqlite" ? "bigint" : "" : ""
  );
  coreImports.push(databaseType !== "sqlite" ? "timestamp, boolean" : "");
  if (databaseType === "mysql") {
    const hasNonBigintNumber = Object.values(tables).some(
      (table) => Object.values(table.fields).some(
        (field) => (field.type === "number" || field.type === "number[]") && !field.bigint
      )
    );
    const needsInt = !!useNumberId || hasNonBigintNumber;
    if (needsInt) {
      coreImports.push("int");
    }
  } else if (databaseType === "pg") {
    const hasNonBigintNumber = Object.values(tables).some(
      (table) => Object.values(table.fields).some(
        (field) => (field.type === "number" || field.type === "number[]") && !field.bigint
      )
    );
    const hasFkToId = Object.values(tables).some(
      (table) => Object.values(table.fields).some(
        (field) => field.references?.field === "id"
      )
    );
    const needsInteger = hasNonBigintNumber || options.advanced?.database?.useNumberId && hasFkToId;
    if (needsInteger) {
      coreImports.push("integer");
    }
  } else {
    coreImports.push("integer");
  }
  coreImports.push(useNumberId ? databaseType === "pg" ? "serial" : "" : "");
  if (hasJson) {
    if (databaseType === "pg") coreImports.push("jsonb");
    if (databaseType === "mysql") coreImports.push("json");
  }
  const hasSQLiteTimestamp = databaseType === "sqlite" && Object.values(tables).some(
    (table) => Object.values(table.fields).some(
      (field) => field.type === "date" && field.defaultValue && typeof field.defaultValue === "function" && field.defaultValue.toString().includes("new Date()")
    )
  );
  if (hasSQLiteTimestamp) {
    rootImports.push("sql");
  }
  return `${rootImports.length > 0 ? `import { ${rootImports.join(", ")} } from "drizzle-orm";
` : ""}import { ${coreImports.map((x) => x.trim()).filter((x) => x !== "").join(", ")} } from "drizzle-orm/${databaseType}-core";
`;
}
function getModelName(modelName, options) {
  return options?.usePlural ? `${modelName}s` : modelName;
}

const generatePrismaSchema = async ({
  adapter,
  options,
  file
}) => {
  const provider = adapter.options?.provider || "postgresql";
  const tables = getAuthTables(options);
  const filePath = file || "./prisma/schema.prisma";
  const schemaPrismaExist = existsSync(path__default.join(process.cwd(), filePath));
  let schemaPrisma = "";
  if (schemaPrismaExist) {
    schemaPrisma = await fs$1.readFile(
      path__default.join(process.cwd(), filePath),
      "utf-8"
    );
  } else {
    schemaPrisma = getNewPrisma(provider);
  }
  const manyToManyRelations = /* @__PURE__ */ new Map();
  for (const table in tables) {
    const fields = tables[table]?.fields;
    for (const field in fields) {
      const attr = fields[field];
      if (attr.references) {
        const referencedOriginalModel = attr.references.model;
        const referencedCustomModel = tables[referencedOriginalModel]?.modelName || referencedOriginalModel;
        const referencedModelNameCap = capitalizeFirstLetter(
          referencedCustomModel
        );
        if (!manyToManyRelations.has(referencedModelNameCap)) {
          manyToManyRelations.set(referencedModelNameCap, /* @__PURE__ */ new Set());
        }
        const currentCustomModel = tables[table]?.modelName || table;
        const currentModelNameCap = capitalizeFirstLetter(currentCustomModel);
        manyToManyRelations.get(referencedModelNameCap).add(currentModelNameCap);
      }
    }
  }
  const schema = produceSchema(schemaPrisma, (builder) => {
    for (const table in tables) {
      let getType = function({
        isBigint,
        isOptional,
        type
      }) {
        if (type === "string") {
          return isOptional ? "String?" : "String";
        }
        if (type === "number" && isBigint) {
          return isOptional ? "BigInt?" : "BigInt";
        }
        if (type === "number") {
          return isOptional ? "Int?" : "Int";
        }
        if (type === "boolean") {
          return isOptional ? "Boolean?" : "Boolean";
        }
        if (type === "date") {
          return isOptional ? "DateTime?" : "DateTime";
        }
        if (type === "json") {
          return isOptional ? "Json?" : "Json";
        }
        if (type === "string[]") {
          return isOptional ? "String[]" : "String[]";
        }
        if (type === "number[]") {
          return isOptional ? "Int[]" : "Int[]";
        }
      };
      const originalTableName = table;
      const customModelName = tables[table]?.modelName || table;
      const modelName = capitalizeFirstLetter(customModelName);
      const fields = tables[table]?.fields;
      const prismaModel = builder.findByType("model", {
        name: modelName
      });
      if (!prismaModel) {
        if (provider === "mongodb") {
          builder.model(modelName).field("id", "String").attribute("id").attribute(`map("_id")`);
        } else {
          if (options.advanced?.database?.useNumberId) {
            builder.model(modelName).field("id", "Int").attribute("id").attribute("default(autoincrement())");
          } else {
            builder.model(modelName).field("id", "String").attribute("id");
          }
        }
      }
      for (const field in fields) {
        const attr = fields[field];
        const fieldName = attr.fieldName || field;
        if (prismaModel) {
          const isAlreadyExist = builder.findByType("field", {
            name: fieldName,
            within: prismaModel.properties
          });
          if (isAlreadyExist) {
            continue;
          }
        }
        const fieldBuilder = builder.model(modelName).field(
          fieldName,
          field === "id" && options.advanced?.database?.useNumberId ? getType({
            isBigint: false,
            isOptional: false,
            type: "number"
          }) : getType({
            isBigint: attr?.bigint || false,
            isOptional: !attr?.required,
            type: attr.references?.field === "id" ? options.advanced?.database?.useNumberId ? "number" : "string" : attr.type
          })
        );
        if (field === "id") {
          fieldBuilder.attribute("id");
          if (provider === "mongodb") {
            fieldBuilder.attribute(`map("_id")`);
          }
        }
        if (attr.unique) {
          builder.model(modelName).blockAttribute(`unique([${fieldName}])`);
        }
        if (attr.defaultValue !== void 0) {
          if (field === "createdAt") {
            fieldBuilder.attribute("default(now())");
          } else if (typeof attr.defaultValue === "boolean") {
            fieldBuilder.attribute(`default(${attr.defaultValue})`);
          } else if (typeof attr.defaultValue === "function") {
            const defaultVal = attr.defaultValue();
            if (defaultVal instanceof Date) {
              fieldBuilder.attribute("default(now())");
            } else {
              console.warn(
                `Warning: Unsupported default function for field ${fieldName} in model ${modelName}. Please adjust manually.`
              );
            }
          }
        }
        if (field === "updatedAt" && attr.onUpdate) {
          fieldBuilder.attribute("updatedAt");
        } else if (attr.onUpdate) {
          console.warn(
            `Warning: 'onUpdate' is only supported on 'updatedAt' fields. Please adjust manually for field ${fieldName} in model ${modelName}.`
          );
        }
        if (attr.references) {
          const referencedOriginalModelName = attr.references.model;
          const referencedCustomModelName = tables[referencedOriginalModelName]?.modelName || referencedOriginalModelName;
          let action = "Cascade";
          if (attr.references.onDelete === "no action") action = "NoAction";
          else if (attr.references.onDelete === "set null") action = "SetNull";
          else if (attr.references.onDelete === "set default")
            action = "SetDefault";
          else if (attr.references.onDelete === "restrict") action = "Restrict";
          builder.model(modelName).field(
            `${referencedCustomModelName.toLowerCase()}`,
            `${capitalizeFirstLetter(referencedCustomModelName)}${!attr.required ? "?" : ""}`
          ).attribute(
            `relation(fields: [${fieldName}], references: [${attr.references.field}], onDelete: ${action})`
          );
        }
        if (!attr.unique && !attr.references && provider === "mysql" && attr.type === "string") {
          builder.model(modelName).field(fieldName).attribute("db.Text");
        }
      }
      if (manyToManyRelations.has(modelName)) {
        for (const relatedModel of manyToManyRelations.get(modelName)) {
          const fieldName = `${relatedModel.toLowerCase()}s`;
          const existingField = builder.findByType("field", {
            name: fieldName,
            within: prismaModel?.properties
          });
          if (!existingField) {
            builder.model(modelName).field(fieldName, `${relatedModel}[]`);
          }
        }
      }
      const hasAttribute = builder.findByType("attribute", {
        name: "map",
        within: prismaModel?.properties
      });
      const hasChanged = customModelName !== originalTableName;
      if (!hasAttribute) {
        builder.model(modelName).blockAttribute(
          "map",
          `${hasChanged ? customModelName : originalTableName}`
        );
      }
    }
  });
  const schemaChanged = schema.trim() !== schemaPrisma.trim();
  return {
    code: schemaChanged ? schema : "",
    fileName: filePath,
    overwrite: schemaPrismaExist && schemaChanged
  };
};
const getNewPrisma = (provider) => `generator client {
    provider = "prisma-client-js"
  }
  
  datasource db {
    provider = "${provider}"
    url      = ${provider === "sqlite" ? `"file:./dev.db"` : `env("DATABASE_URL")`}
  }`;

const generateMigrations = async ({
  options,
  file
}) => {
  const { compileMigrations } = await getMigrations(options);
  const migrations = await compileMigrations();
  return {
    code: migrations.trim() === ";" ? "" : migrations,
    fileName: file || `./better-auth_migrations/${(/* @__PURE__ */ new Date()).toISOString().replace(/:/g, "-")}.sql`
  };
};

const adapters = {
  prisma: generatePrismaSchema,
  drizzle: generateDrizzleSchema,
  kysely: generateMigrations
};
const generateSchema = (opts) => {
  const adapter = opts.adapter;
  const generator = adapter.id in adapters ? adapters[adapter.id] : null;
  if (generator) {
    return generator(opts);
  }
  if (adapter.createSchema) {
    return adapter.createSchema(opts.options, opts.file).then(({ code, path: fileName, overwrite }) => ({
      code,
      fileName,
      overwrite
    }));
  }
  logger.error(
    `${adapter.id} is not supported. If it is a custom adapter, please request the maintainer to implement createSchema`
  );
  process.exit(1);
};

async function generateAction(opts) {
  const options = z.object({
    cwd: z.string(),
    config: z.string().optional(),
    output: z.string().optional(),
    y: z.boolean().optional(),
    yes: z.boolean().optional()
  }).parse(opts);
  const cwd = path__default.resolve(options.cwd);
  if (!existsSync(cwd)) {
    logger.error(`The directory "${cwd}" does not exist.`);
    process.exit(1);
  }
  const config = await getConfig({
    cwd,
    configPath: options.config
  });
  if (!config) {
    logger.error(
      "No configuration file found. Add a `auth.ts` file to your project or pass the path to the configuration file using the `--config` flag."
    );
    return;
  }
  const adapter = await getAdapter(config).catch((e) => {
    logger.error(e.message);
    process.exit(1);
  });
  const spinner = yoctoSpinner({ text: "preparing schema..." }).start();
  const schema = await generateSchema({
    adapter,
    file: options.output,
    options: config
  });
  spinner.stop();
  if (!schema.code) {
    logger.info("Your schema is already up to date.");
    try {
      const telemetry = await createTelemetry(config);
      await telemetry.publish({
        type: "cli_generate",
        payload: {
          outcome: "no_changes",
          config: getTelemetryAuthConfig(config, {
            adapter: adapter.id,
            database: typeof config.database === "function" ? "adapter" : "kysely"
          })
        }
      });
    } catch {
    }
    process.exit(0);
  }
  if (schema.overwrite) {
    let confirm2 = options.y || options.yes;
    if (!confirm2) {
      const response = await prompts({
        type: "confirm",
        name: "confirm",
        message: `The file ${schema.fileName} already exists. Do you want to ${chalk.yellow(
          `${schema.overwrite ? "overwrite" : "append"}`
        )} the schema to the file?`
      });
      confirm2 = response.confirm;
    }
    if (confirm2) {
      const exist = existsSync(path__default.join(cwd, schema.fileName));
      if (!exist) {
        await fs$1.mkdir(path__default.dirname(path__default.join(cwd, schema.fileName)), {
          recursive: true
        });
      }
      if (schema.overwrite) {
        await fs$1.writeFile(path__default.join(cwd, schema.fileName), schema.code);
      } else {
        await fs$1.appendFile(path__default.join(cwd, schema.fileName), schema.code);
      }
      logger.success(
        `\u{1F680} Schema was ${schema.overwrite ? "overwritten" : "appended"} successfully!`
      );
      try {
        const telemetry = await createTelemetry(config);
        await telemetry.publish({
          type: "cli_generate",
          payload: {
            outcome: schema.overwrite ? "overwritten" : "appended",
            config: getTelemetryAuthConfig(config)
          }
        });
      } catch {
      }
      process.exit(0);
    } else {
      logger.error("Schema generation aborted.");
      try {
        const telemetry = await createTelemetry(config);
        await telemetry.publish({
          type: "cli_generate",
          payload: {
            outcome: "aborted",
            config: getTelemetryAuthConfig(config)
          }
        });
      } catch {
      }
      process.exit(1);
    }
  }
  if (options.y) {
    console.warn("WARNING: --y is deprecated. Consider -y or --yes");
    options.yes = true;
  }
  let confirm = options.yes;
  if (!confirm) {
    const response = await prompts({
      type: "confirm",
      name: "confirm",
      message: `Do you want to generate the schema to ${chalk.yellow(
        schema.fileName
      )}?`
    });
    confirm = response.confirm;
  }
  if (!confirm) {
    logger.error("Schema generation aborted.");
    try {
      const telemetry = await createTelemetry(config);
      await telemetry.publish({
        type: "cli_generate",
        payload: { outcome: "aborted", config: getTelemetryAuthConfig(config) }
      });
    } catch {
    }
    process.exit(1);
  }
  if (!options.output) {
    const dirExist = existsSync(path__default.dirname(path__default.join(cwd, schema.fileName)));
    if (!dirExist) {
      await fs$1.mkdir(path__default.dirname(path__default.join(cwd, schema.fileName)), {
        recursive: true
      });
    }
  }
  await fs$1.writeFile(
    options.output || path__default.join(cwd, schema.fileName),
    schema.code
  );
  logger.success(`\u{1F680} Schema was generated successfully!`);
  try {
    const telemetry = await createTelemetry(config);
    await telemetry.publish({
      type: "cli_generate",
      payload: { outcome: "generated", config: getTelemetryAuthConfig(config) }
    });
  } catch {
  }
  process.exit(0);
}
const generate = new Command("generate").option(
  "-c, --cwd <cwd>",
  "the working directory. defaults to the current directory.",
  process.cwd()
).option(
  "--config <config>",
  "the path to the configuration file. defaults to the first configuration file found."
).option("--output <output>", "the file to output to the generated schema").option("-y, --yes", "automatically answer yes to all prompts", false).option("--y", "(deprecated) same as --yes", false).action(generateAction);

const DEMO_URL = "https://demo.better-auth.com";
const CLIENT_ID = "better-auth-cli";
const CONFIG_DIR = path__default.join(os__default.homedir(), ".better-auth");
const TOKEN_FILE = path__default.join(CONFIG_DIR, "token.json");
async function loginAction(opts) {
  const options = z.object({
    serverUrl: z.string().optional(),
    clientId: z.string().optional()
  }).parse(opts);
  const serverUrl = options.serverUrl || DEMO_URL;
  const clientId = options.clientId || CLIENT_ID;
  intro(chalk.bold("\u{1F510} Better Auth CLI Login (Demo)"));
  console.log(
    chalk.yellow(
      "\u26A0\uFE0F  This is a demo feature for testing device authorization flow."
    )
  );
  console.log(
    chalk.gray(
      "   It connects to the Better Auth demo server for testing purposes.\n"
    )
  );
  const existingToken = await getStoredToken();
  if (existingToken) {
    const shouldReauth = await confirm({
      message: "You're already logged in. Do you want to log in again?",
      initialValue: false
    });
    if (isCancel(shouldReauth) || !shouldReauth) {
      cancel("Login cancelled");
      process.exit(0);
    }
  }
  const authClient = createAuthClient({
    baseURL: serverUrl,
    plugins: [deviceAuthorizationClient()]
  });
  const spinner = yoctoSpinner({ text: "Requesting device authorization..." });
  spinner.start();
  try {
    const { data, error } = await authClient.device.code({
      client_id: clientId,
      scope: "openid profile email"
    });
    spinner.stop();
    if (error || !data) {
      logger.error(
        `Failed to request device authorization: ${error?.error_description || "Unknown error"}`
      );
      process.exit(1);
    }
    const {
      device_code,
      user_code,
      verification_uri,
      verification_uri_complete,
      interval = 5,
      expires_in
    } = data;
    console.log("");
    console.log(chalk.cyan("\u{1F4F1} Device Authorization Required"));
    console.log("");
    console.log(`Please visit: ${chalk.underline.blue(verification_uri)}`);
    console.log(`Enter code: ${chalk.bold.green(user_code)}`);
    console.log("");
    const shouldOpen = await confirm({
      message: "Open browser automatically?",
      initialValue: true
    });
    if (!isCancel(shouldOpen) && shouldOpen) {
      const urlToOpen = verification_uri_complete || verification_uri;
      await open(urlToOpen);
    }
    console.log(
      chalk.gray(
        `Waiting for authorization (expires in ${Math.floor(expires_in / 60)} minutes)...`
      )
    );
    const token = await pollForToken(
      authClient,
      device_code,
      clientId,
      interval
    );
    if (token) {
      await storeToken(token);
      const { data: session } = await authClient.getSession({
        fetchOptions: {
          headers: {
            Authorization: `Bearer ${token.access_token}`
          }
        }
      });
      outro(
        chalk.green(
          `\u2705 Demo login successful! Logged in as ${session?.user?.name || session?.user?.email || "User"}`
        )
      );
      console.log(
        chalk.gray(
          "\n\u{1F4DD} Note: This was a demo authentication for testing purposes."
        )
      );
      console.log(
        chalk.blue(
          "\nFor more information, visit: https://better-auth.com/docs/plugins/device-authorization"
        )
      );
    }
  } catch (err) {
    spinner.stop();
    logger.error(
      `Login failed: ${err instanceof Error ? err.message : "Unknown error"}`
    );
    process.exit(1);
  }
}
async function pollForToken(authClient, deviceCode, clientId, initialInterval) {
  let pollingInterval = initialInterval;
  const spinner = yoctoSpinner({ text: "", color: "cyan" });
  let dots = 0;
  return new Promise((resolve, reject) => {
    const poll = async () => {
      dots = (dots + 1) % 4;
      spinner.text = chalk.gray(
        `Polling for authorization${".".repeat(dots)}${" ".repeat(3 - dots)}`
      );
      if (!spinner.isSpinning) spinner.start();
      try {
        const { data, error } = await authClient.device.token({
          grant_type: "urn:ietf:params:oauth:grant-type:device_code",
          device_code: deviceCode,
          client_id: clientId,
          fetchOptions: {
            headers: {
              "user-agent": `Better Auth CLI`
            }
          }
        });
        if (data?.access_token) {
          spinner.stop();
          resolve(data);
          return;
        } else if (error) {
          switch (error.error) {
            case "authorization_pending":
              break;
            case "slow_down":
              pollingInterval += 5;
              spinner.text = chalk.yellow(
                `Slowing down polling to ${pollingInterval}s`
              );
              break;
            case "access_denied":
              spinner.stop();
              logger.error("Access was denied by the user");
              process.exit(1);
              break;
            case "expired_token":
              spinner.stop();
              logger.error("The device code has expired. Please try again.");
              process.exit(1);
              break;
            default:
              spinner.stop();
              logger.error(`Error: ${error.error_description}`);
              process.exit(1);
          }
        }
      } catch (err) {
        spinner.stop();
        logger.error(
          `Network error: ${err instanceof Error ? err.message : "Unknown error"}`
        );
        process.exit(1);
      }
      setTimeout(poll, pollingInterval * 1e3);
    };
    setTimeout(poll, pollingInterval * 1e3);
  });
}
async function storeToken(token) {
  try {
    await fs$1.mkdir(CONFIG_DIR, { recursive: true });
    const tokenData = {
      access_token: token.access_token,
      token_type: token.token_type || "Bearer",
      scope: token.scope,
      created_at: (/* @__PURE__ */ new Date()).toISOString()
    };
    await fs$1.writeFile(TOKEN_FILE, JSON.stringify(tokenData, null, 2), "utf-8");
  } catch (error) {
    logger.warn("Failed to store authentication token locally");
  }
}
async function getStoredToken() {
  try {
    const data = await fs$1.readFile(TOKEN_FILE, "utf-8");
    return JSON.parse(data);
  } catch {
    return null;
  }
}
const login = new Command("login").description(
  "Demo: Test device authorization flow with Better Auth demo server"
).option("--server-url <url>", "The Better Auth server URL", DEMO_URL).option("--client-id <id>", "The OAuth client ID", CLIENT_ID).action(loginAction);

function getSystemInfo() {
  const platform = os__default.platform();
  const arch = os__default.arch();
  const version = os__default.version();
  const release = os__default.release();
  const cpus = os__default.cpus();
  const memory = os__default.totalmem();
  const freeMemory = os__default.freemem();
  return {
    platform,
    arch,
    version,
    release,
    cpuCount: cpus.length,
    cpuModel: cpus[0]?.model || "Unknown",
    totalMemory: `${(memory / 1024 / 1024 / 1024).toFixed(2)} GB`,
    freeMemory: `${(freeMemory / 1024 / 1024 / 1024).toFixed(2)} GB`
  };
}
function getNodeInfo() {
  return {
    version: process.version,
    env: process.env.NODE_ENV || "development"
  };
}
function getPackageManager() {
  const userAgent = process.env.npm_config_user_agent || "";
  if (userAgent.includes("yarn")) {
    return { name: "yarn", version: getVersion("yarn") };
  }
  if (userAgent.includes("pnpm")) {
    return { name: "pnpm", version: getVersion("pnpm") };
  }
  if (userAgent.includes("bun")) {
    return { name: "bun", version: getVersion("bun") };
  }
  return { name: "npm", version: getVersion("npm") };
}
function getVersion(command) {
  try {
    const output = execSync(`${command} --version`, { encoding: "utf8" });
    return output.trim();
  } catch {
    return "Not installed";
  }
}
function getFrameworkInfo(projectRoot) {
  const packageJsonPath = path__default.join(projectRoot, "package.json");
  if (!existsSync(packageJsonPath)) {
    return null;
  }
  try {
    const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf8"));
    const deps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies
    };
    const frameworks = {
      next: deps["next"],
      react: deps["react"],
      vue: deps["vue"],
      nuxt: deps["nuxt"],
      svelte: deps["svelte"],
      "@sveltejs/kit": deps["@sveltejs/kit"],
      express: deps["express"],
      fastify: deps["fastify"],
      hono: deps["hono"],
      remix: deps["@remix-run/react"],
      astro: deps["astro"],
      solid: deps["solid-js"],
      qwik: deps["@builder.io/qwik"]
    };
    const installedFrameworks = Object.entries(frameworks).filter(([_, version]) => version).map(([name, version]) => ({ name, version }));
    return installedFrameworks.length > 0 ? installedFrameworks : null;
  } catch {
    return null;
  }
}
function getDatabaseInfo(projectRoot) {
  const packageJsonPath = path__default.join(projectRoot, "package.json");
  if (!existsSync(packageJsonPath)) {
    return null;
  }
  try {
    const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf8"));
    const deps = {
      ...packageJson.dependencies,
      ...packageJson.devDependencies
    };
    const databases = {
      "better-sqlite3": deps["better-sqlite3"],
      "@libsql/client": deps["@libsql/client"],
      "@libsql/kysely-libsql": deps["@libsql/kysely-libsql"],
      mysql2: deps["mysql2"],
      pg: deps["pg"],
      postgres: deps["postgres"],
      "@prisma/client": deps["@prisma/client"],
      drizzle: deps["drizzle-orm"],
      kysely: deps["kysely"],
      mongodb: deps["mongodb"],
      "@neondatabase/serverless": deps["@neondatabase/serverless"],
      "@vercel/postgres": deps["@vercel/postgres"],
      "@planetscale/database": deps["@planetscale/database"]
    };
    const installedDatabases = Object.entries(databases).filter(([_, version]) => version).map(([name, version]) => ({ name, version }));
    return installedDatabases.length > 0 ? installedDatabases : null;
  } catch {
    return null;
  }
}
function sanitizeBetterAuthConfig(config) {
  if (!config) return null;
  const sanitized = JSON.parse(JSON.stringify(config));
  const sensitiveKeys = [
    "secret",
    "clientSecret",
    "clientId",
    "authToken",
    "apiKey",
    "apiSecret",
    "privateKey",
    "publicKey",
    "password",
    "token",
    "webhook",
    "connectionString",
    "databaseUrl",
    "databaseURL",
    "TURSO_AUTH_TOKEN",
    "TURSO_DATABASE_URL",
    "MYSQL_DATABASE_URL",
    "DATABASE_URL",
    "POSTGRES_URL",
    "MONGODB_URI",
    "stripeKey",
    "stripeWebhookSecret"
  ];
  const allowedKeys = [
    "baseURL",
    "callbackURL",
    "redirectURL",
    "trustedOrigins",
    "appName"
  ];
  function redactSensitive(obj, parentKey) {
    if (typeof obj !== "object" || obj === null) {
      if (parentKey && typeof obj === "string" && obj.length > 0) {
        if (allowedKeys.some(
          (allowed) => parentKey.toLowerCase() === allowed.toLowerCase()
        )) {
          return obj;
        }
        const lowerKey = parentKey.toLowerCase();
        if (sensitiveKeys.some((key) => {
          const lowerSensitiveKey = key.toLowerCase();
          return lowerKey === lowerSensitiveKey || lowerKey.endsWith(lowerSensitiveKey);
        })) {
          return "[REDACTED]";
        }
      }
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => redactSensitive(item, parentKey));
    }
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      if (allowedKeys.some(
        (allowed) => key.toLowerCase() === allowed.toLowerCase()
      )) {
        result[key] = value;
        continue;
      }
      const lowerKey = key.toLowerCase();
      if (sensitiveKeys.some((sensitiveKey) => {
        const lowerSensitiveKey = sensitiveKey.toLowerCase();
        return lowerKey === lowerSensitiveKey || lowerKey.endsWith(lowerSensitiveKey);
      })) {
        if (typeof value === "string" && value.length > 0) {
          result[key] = "[REDACTED]";
        } else if (typeof value === "object" && value !== null) {
          result[key] = redactSensitive(value, key);
        } else {
          result[key] = value;
        }
      } else {
        result[key] = redactSensitive(value, key);
      }
    }
    return result;
  }
  if (sanitized.database) {
    if (typeof sanitized.database === "string") {
      sanitized.database = "[REDACTED]";
    } else if (sanitized.database.url) {
      sanitized.database.url = "[REDACTED]";
    }
    if (sanitized.database.authToken) {
      sanitized.database.authToken = "[REDACTED]";
    }
  }
  if (sanitized.socialProviders) {
    for (const provider in sanitized.socialProviders) {
      if (sanitized.socialProviders[provider]) {
        sanitized.socialProviders[provider] = redactSensitive(
          sanitized.socialProviders[provider],
          provider
        );
      }
    }
  }
  if (sanitized.emailAndPassword?.sendResetPassword) {
    sanitized.emailAndPassword.sendResetPassword = "[Function]";
  }
  if (sanitized.emailVerification?.sendVerificationEmail) {
    sanitized.emailVerification.sendVerificationEmail = "[Function]";
  }
  if (sanitized.plugins && Array.isArray(sanitized.plugins)) {
    sanitized.plugins = sanitized.plugins.map((plugin) => {
      if (typeof plugin === "function") {
        return "[Plugin Function]";
      }
      if (plugin && typeof plugin === "object") {
        const pluginName = plugin.id || plugin.name || "unknown";
        return {
          name: pluginName,
          config: redactSensitive(plugin.config || plugin)
        };
      }
      return plugin;
    });
  }
  return redactSensitive(sanitized);
}
async function getBetterAuthInfo(projectRoot, configPath, suppressLogs = false) {
  try {
    const originalLog = console.log;
    const originalWarn = console.warn;
    const originalError = console.error;
    if (suppressLogs) {
      console.log = () => {
      };
      console.warn = () => {
      };
      console.error = () => {
      };
    }
    try {
      const config = await getConfig({
        cwd: projectRoot,
        configPath,
        shouldThrowOnError: false
      });
      const packageInfo = await getPackageInfo();
      const betterAuthVersion = packageInfo.dependencies?.["better-auth"] || packageInfo.devDependencies?.["better-auth"] || packageInfo.peerDependencies?.["better-auth"] || packageInfo.optionalDependencies?.["better-auth"] || "Unknown";
      return {
        version: betterAuthVersion,
        config: sanitizeBetterAuthConfig(config)
      };
    } finally {
      if (suppressLogs) {
        console.log = originalLog;
        console.warn = originalWarn;
        console.error = originalError;
      }
    }
  } catch (error) {
    return {
      version: "Unknown",
      config: null,
      error: error instanceof Error ? error.message : "Failed to load Better Auth config"
    };
  }
}
function formatOutput(data, indent = 0) {
  const spaces = " ".repeat(indent);
  if (data === null || data === void 0) {
    return `${spaces}${chalk.gray("N/A")}`;
  }
  if (typeof data === "string" || typeof data === "number" || typeof data === "boolean") {
    return `${spaces}${data}`;
  }
  if (Array.isArray(data)) {
    if (data.length === 0) {
      return `${spaces}${chalk.gray("[]")}`;
    }
    return data.map((item) => formatOutput(item, indent)).join("\n");
  }
  if (typeof data === "object") {
    const entries = Object.entries(data);
    if (entries.length === 0) {
      return `${spaces}${chalk.gray("{}")}`;
    }
    return entries.map(([key, value]) => {
      if (typeof value === "object" && value !== null && !Array.isArray(value)) {
        return `${spaces}${chalk.cyan(key)}:
${formatOutput(value, indent + 2)}`;
      }
      return `${spaces}${chalk.cyan(key)}: ${formatOutput(value, 0)}`;
    }).join("\n");
  }
  return `${spaces}${JSON.stringify(data)}`;
}
const info = new Command("info").description("Display system and Better Auth configuration information").option("--cwd <cwd>", "The working directory", process.cwd()).option("--config <config>", "Path to the Better Auth configuration file").option("-j, --json", "Output as JSON").option("-c, --copy", "Copy output to clipboard (requires pbcopy/xclip)").action(async (options) => {
  const projectRoot = path__default.resolve(options.cwd || process.cwd());
  const systemInfo = getSystemInfo();
  const nodeInfo = getNodeInfo();
  const packageManager = getPackageManager();
  const frameworks = getFrameworkInfo(projectRoot);
  const databases = getDatabaseInfo(projectRoot);
  const betterAuthInfo = await getBetterAuthInfo(
    projectRoot,
    options.config,
    options.json
  );
  const fullInfo = {
    system: systemInfo,
    node: nodeInfo,
    packageManager,
    frameworks,
    databases,
    betterAuth: betterAuthInfo
  };
  if (options.json) {
    const jsonOutput = JSON.stringify(fullInfo, null, 2);
    console.log(jsonOutput);
    if (options.copy) {
      try {
        const platform = os__default.platform();
        if (platform === "darwin") {
          execSync("pbcopy", { input: jsonOutput });
          console.log(chalk.green("\n\u2713 Copied to clipboard"));
        } else if (platform === "linux") {
          execSync("xclip -selection clipboard", { input: jsonOutput });
          console.log(chalk.green("\n\u2713 Copied to clipboard"));
        } else if (platform === "win32") {
          execSync("clip", { input: jsonOutput });
          console.log(chalk.green("\n\u2713 Copied to clipboard"));
        }
      } catch {
        console.log(chalk.yellow("\n\u26A0 Could not copy to clipboard"));
      }
    }
    return;
  }
  console.log(chalk.bold("\n\u{1F4CA} Better Auth System Information\n"));
  console.log(chalk.gray("=".repeat(50)));
  console.log(chalk.bold.white("\n\u{1F5A5}\uFE0F  System Information:"));
  console.log(formatOutput(systemInfo, 2));
  console.log(chalk.bold.white("\n\u{1F4E6} Node.js:"));
  console.log(formatOutput(nodeInfo, 2));
  console.log(chalk.bold.white("\n\u{1F4E6} Package Manager:"));
  console.log(formatOutput(packageManager, 2));
  if (frameworks) {
    console.log(chalk.bold.white("\n\u{1F680} Frameworks:"));
    console.log(formatOutput(frameworks, 2));
  }
  if (databases) {
    console.log(chalk.bold.white("\n\u{1F4BE} Database Clients:"));
    console.log(formatOutput(databases, 2));
  }
  console.log(chalk.bold.white("\n\u{1F510} Better Auth:"));
  if (betterAuthInfo.error) {
    console.log(`  ${chalk.red("Error:")} ${betterAuthInfo.error}`);
  } else {
    console.log(`  ${chalk.cyan("Version")}: ${betterAuthInfo.version}`);
    if (betterAuthInfo.config) {
      console.log(`  ${chalk.cyan("Configuration")}:`);
      console.log(formatOutput(betterAuthInfo.config, 4));
    }
  }
  console.log(chalk.gray("\n" + "=".repeat(50)));
  console.log(chalk.gray("\n\u{1F4A1} Tip: Use --json flag for JSON output"));
  console.log(chalk.gray("\u{1F4A1} Use --copy flag to copy output to clipboard"));
  console.log(
    chalk.gray("\u{1F4A1} When reporting issues, include this information\n")
  );
  if (options.copy) {
    const textOutput = `
Better Auth System Information
==============================

System Information:
${JSON.stringify(systemInfo, null, 2)}

Node.js:
${JSON.stringify(nodeInfo, null, 2)}

Package Manager:
${JSON.stringify(packageManager, null, 2)}

Frameworks:
${JSON.stringify(frameworks, null, 2)}

Database Clients:
${JSON.stringify(databases, null, 2)}

Better Auth:
${JSON.stringify(betterAuthInfo, null, 2)}
`;
    try {
      const platform = os__default.platform();
      if (platform === "darwin") {
        execSync("pbcopy", { input: textOutput });
        console.log(chalk.green("\u2713 Copied to clipboard"));
      } else if (platform === "linux") {
        execSync("xclip -selection clipboard", { input: textOutput });
        console.log(chalk.green("\u2713 Copied to clipboard"));
      } else if (platform === "win32") {
        execSync("clip", { input: textOutput });
        console.log(chalk.green("\u2713 Copied to clipboard"));
      }
    } catch {
      console.log(chalk.yellow("\u26A0 Could not copy to clipboard"));
    }
  }
});

async function mcpAction(options) {
  const mcpUrl = "https://mcp.chonkie.ai/better-auth/better-auth-builder/mcp";
  const mcpName = "Better Auth";
  if (options.cursor) {
    await handleCursorAction(mcpUrl, mcpName);
  } else if (options.claudeCode) {
    handleClaudeCodeAction(mcpUrl);
  } else if (options.openCode) {
    handleOpenCodeAction(mcpUrl);
  } else if (options.manual) {
    handleManualAction(mcpUrl, mcpName);
  } else {
    showAllOptions();
  }
}
async function handleCursorAction(mcpUrl, mcpName) {
  const mcpConfig = {
    url: mcpUrl
  };
  const encodedConfig = base64.encode(
    new TextEncoder().encode(JSON.stringify(mcpConfig))
  );
  const deeplinkUrl = `cursor://anysphere.cursor-deeplink/mcp/install?name=${encodeURIComponent(mcpName)}&config=${encodedConfig}`;
  console.log(chalk.bold.blue("\u{1F680} Adding Better Auth MCP to Cursor..."));
  try {
    const platform = os.platform();
    let command;
    switch (platform) {
      case "darwin":
        command = `open "${deeplinkUrl}"`;
        break;
      case "win32":
        command = `start "" "${deeplinkUrl}"`;
        break;
      case "linux":
        command = `xdg-open "${deeplinkUrl}"`;
        break;
      default:
        throw new Error(`Unsupported platform: ${platform}`);
    }
    execSync(command, { stdio: "inherit" });
    console.log(chalk.green("\n\u2713 Cursor MCP installed successfully!"));
  } catch (error) {
    console.log(
      chalk.yellow(
        "\n\u26A0 Could not automatically open Cursor. Please copy the deeplink URL above and open it manually."
      )
    );
    console.log(
      chalk.gray(
        "\nYou can also manually add this configuration to your Cursor MCP settings:"
      )
    );
    console.log(chalk.gray(JSON.stringify(mcpConfig, null, 2)));
  }
  console.log(chalk.bold.white("\n\u2728 Next Steps:"));
  console.log(
    chalk.gray("\u2022 The MCP server will be added to your Cursor configuration")
  );
  console.log(
    chalk.gray("\u2022 You can now use Better Auth features directly in Cursor")
  );
}
function handleClaudeCodeAction(mcpUrl) {
  console.log(chalk.bold.blue("\u{1F916} Adding Better Auth MCP to Claude Code..."));
  const command = `claude mcp add --transport http better-auth ${mcpUrl}`;
  try {
    execSync(command, { stdio: "inherit" });
    console.log(chalk.green("\n\u2713 Claude Code MCP installed successfully!"));
  } catch (error) {
    console.log(
      chalk.yellow(
        "\n\u26A0 Could not automatically add to Claude Code. Please run this command manually:"
      )
    );
    console.log(chalk.cyan(command));
  }
  console.log(chalk.bold.white("\n\u2728 Next Steps:"));
  console.log(
    chalk.gray(
      "\u2022 The MCP server will be added to your Claude Code configuration"
    )
  );
  console.log(
    chalk.gray(
      "\u2022 You can now use Better Auth features directly in Claude Code"
    )
  );
}
function handleOpenCodeAction(mcpUrl) {
  console.log(chalk.bold.blue("\u{1F527} Adding Better Auth MCP to Open Code..."));
  const openCodeConfig = {
    $schema: "https://opencode.ai/config.json",
    mcp: {
      "Better Auth": {
        type: "remote",
        url: mcpUrl,
        enabled: true
      }
    }
  };
  const configPath = path.join(process.cwd(), "opencode.json");
  try {
    let existingConfig = {};
    if (fs.existsSync(configPath)) {
      const existingContent = fs.readFileSync(configPath, "utf8");
      existingConfig = JSON.parse(existingContent);
    }
    const mergedConfig = {
      ...existingConfig,
      ...openCodeConfig,
      mcp: {
        ...existingConfig.mcp,
        ...openCodeConfig.mcp
      }
    };
    fs.writeFileSync(configPath, JSON.stringify(mergedConfig, null, 2));
    console.log(
      chalk.green(`
\u2713 Open Code configuration written to ${configPath}`)
    );
    console.log(chalk.green("\u2713 Better Auth MCP added successfully!"));
  } catch (error) {
    console.log(
      chalk.yellow(
        "\n\u26A0 Could not automatically write opencode.json. Please add this configuration manually:"
      )
    );
    console.log(chalk.cyan(JSON.stringify(openCodeConfig, null, 2)));
  }
  console.log(chalk.bold.white("\n\u2728 Next Steps:"));
  console.log(chalk.gray("\u2022 Restart Open Code to load the new MCP server"));
  console.log(
    chalk.gray("\u2022 You can now use Better Auth features directly in Open Code")
  );
}
function handleManualAction(mcpUrl, mcpName) {
  console.log(chalk.bold.blue("\u{1F4DD} Adding Better Auth MCP Configuration..."));
  const manualConfig = {
    [mcpName]: {
      url: mcpUrl
    }
  };
  const configPath = path.join(process.cwd(), "mcp.json");
  try {
    let existingConfig = {};
    if (fs.existsSync(configPath)) {
      const existingContent = fs.readFileSync(configPath, "utf8");
      existingConfig = JSON.parse(existingContent);
    }
    const mergedConfig = {
      ...existingConfig,
      ...manualConfig
    };
    fs.writeFileSync(configPath, JSON.stringify(mergedConfig, null, 2));
    console.log(chalk.green(`
\u2713 MCP configuration written to ${configPath}`));
    console.log(chalk.green("\u2713 Better Auth MCP added successfully!"));
  } catch (error) {
    console.log(
      chalk.yellow(
        "\n\u26A0 Could not automatically write mcp.json. Please add this configuration manually:"
      )
    );
    console.log(chalk.cyan(JSON.stringify(manualConfig, null, 2)));
  }
  console.log(chalk.bold.white("\n\u2728 Next Steps:"));
  console.log(chalk.gray("\u2022 Restart your MCP client to load the new server"));
  console.log(
    chalk.gray(
      "\u2022 You can now use Better Auth features directly in your MCP client"
    )
  );
}
function showAllOptions(mcpUrl, mcpName) {
  console.log(chalk.bold.blue("\u{1F50C} Better Auth MCP Server"));
  console.log(chalk.gray("Choose your MCP client to get started:"));
  console.log();
  console.log(chalk.bold.white("Available Commands:"));
  console.log(chalk.cyan("  --cursor      ") + chalk.gray("Add to Cursor"));
  console.log(
    chalk.cyan("  --claude-code ") + chalk.gray("Add to Claude Code")
  );
  console.log(chalk.cyan("  --open-code   ") + chalk.gray("Add to Open Code"));
  console.log(
    chalk.cyan("  --manual      ") + chalk.gray("Manual configuration")
  );
  console.log();
}
const mcp = new Command("mcp").description("Add Better Auth MCP server to MCP Clients").option("--cursor", "Automatically open Cursor with the MCP configuration").option("--claude-code", "Show Claude Code MCP configuration command").option("--open-code", "Show Open Code MCP configuration").option("--manual", "Show manual MCP configuration for mcp.json").action(mcpAction);

process.on("SIGINT", () => process.exit(0));
process.on("SIGTERM", () => process.exit(0));
async function main() {
  const program = new Command("better-auth");
  let packageInfo = {};
  try {
    packageInfo = await getPackageInfo();
  } catch (error) {
  }
  program.addCommand(init).addCommand(migrate).addCommand(generate).addCommand(generateSecret).addCommand(info).addCommand(login).addCommand(mcp).version(packageInfo.version || "1.1.2").description("Better Auth CLI").action(() => program.help());
  program.parse();
}
main().catch((error) => {
  console.error("Error running Better Auth CLI:", error);
  process.exit(1);
});
